{"version":3,"file":"reuse-tab.service.d.ts","sources":["reuse-tab.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { Injector, OnDestroy } from '@angular/core';\nimport { ActivatedRouteSnapshot } from '@angular/router';\nimport { Observable } from 'rxjs';\nimport { MenuService } from '@delon/theme';\nimport type { NzSafeAny } from 'ng-zorro-antd/core/types';\nimport { ReuseComponentRef, ReuseHookOnReuseInitType, ReuseHookTypes, ReuseTabCached, ReuseTabMatchMode, ReuseTabNotify, ReuseTabRouteParamMatchMode, ReuseTitle } from './reuse-tab.interfaces';\nexport declare class ReuseTabService implements OnDestroy {\n    private injector;\n    private menuService;\n    private _inited;\n    private _max;\n    private _keepingScroll;\n    private _cachedChange;\n    private _cached;\n    private _titleCached;\n    private _closableCached;\n    private _router$;\n    private removeUrlBuffer;\n    private positionBuffer;\n    componentRef: ReuseComponentRef;\n    debug: boolean;\n    routeParamMatchMode: ReuseTabRouteParamMatchMode;\n    mode: ReuseTabMatchMode;\n    /** 排除规则，限 `mode=URL` */\n    excludes: RegExp[];\n    private get snapshot();\n    /**\n     * Get init status\n     *\n     * 是否已经初始化完成\n     */\n    get inited(): boolean;\n    /**\n     * Current routing address\n     *\n     * 当前路由地址\n     */\n    get curUrl(): string;\n    /**\n     * 允许最多复用多少个页面，取值范围 `2-100`，值发生变更时会强制关闭且忽略可关闭条件\n     */\n    set max(value: number);\n    set keepingScroll(value: boolean);\n    get keepingScroll(): boolean;\n    keepingScrollContainer: Element;\n    /** 获取已缓存的路由 */\n    get items(): ReuseTabCached[];\n    /** 获取当前缓存的路由总数 */\n    get count(): number;\n    /** 订阅缓存变更通知 */\n    get change(): Observable<ReuseTabNotify | null>;\n    /** 自定义当前标题 */\n    set title(value: string | ReuseTitle);\n    /** 获取指定路径缓存所在位置，`-1` 表示无缓存 */\n    index(url: string): number;\n    /** 获取指定路径缓存是否存在 */\n    exists(url: string): boolean;\n    /** 获取指定路径缓存 */\n    get(url?: string): ReuseTabCached | null;\n    private remove;\n    /**\n     * 根据URL移除标签\n     *\n     * @param [includeNonCloseable=false] 是否强制包含不可关闭\n     */\n    close(url: string, includeNonCloseable?: boolean): boolean;\n    /**\n     * 清除右边\n     *\n     * @param [includeNonCloseable=false] 是否强制包含不可关闭\n     */\n    closeRight(url: string, includeNonCloseable?: boolean): boolean;\n    /**\n     * 清除所有缓存\n     *\n     * @param [includeNonCloseable=false] 是否强制包含不可关闭\n     */\n    clear(includeNonCloseable?: boolean): void;\n    /**\n     * 移动缓存数据\n     *\n     * @param url 要移动的URL地址\n     * @param position 新位置，下标从 `0` 开始\n     *\n     * @example\n     * ```\n     * // source\n     * [ '/a/1', '/a/2', '/a/3', '/a/4', '/a/5' ]\n     * move('/a/1', 2);\n     * // output\n     * [ '/a/2', '/a/3', '/a/1', '/a/4', '/a/5' ]\n     * move('/a/1', -1);\n     * // output\n     * [ '/a/2', '/a/3', '/a/4', '/a/5', '/a/1' ]\n     * ```\n     */\n    move(url: string, position: number): void;\n    /**\n     * 强制关闭当前路由（包含不可关闭状态），并重新导航至 `newUrl` 路由\n     */\n    replace(newUrl: string): void;\n    /**\n     * 获取标题，顺序如下：\n     *\n     * 1. 组件内使用 `ReuseTabService.title = 'new title'` 重新指定文本\n     * 2. 路由配置中 data 属性中包含 titleI18n > title\n     * 3. 菜单数据中 text 属性\n     *\n     * @param url 指定URL\n     * @param route 指定路由快照\n     */\n    getTitle(url: string, route?: ActivatedRouteSnapshot): ReuseTitle;\n    /**\n     * 清除标题缓存\n     */\n    clearTitleCached(): void;\n    /** 自定义当前 `closable` 状态 */\n    set closable(value: boolean);\n    /**\n     * 获取 `closable` 状态，顺序如下：\n     *\n     * 1. 组件内使用 `ReuseTabService.closable = true` 重新指定 `closable` 状态\n     * 2. 路由配置中 data 属性中包含 `reuseClosable`\n     * 3. 菜单数据中 `reuseClosable` 属性\n     *\n     * @param url 指定URL\n     * @param route 指定路由快照\n     */\n    getClosable(url: string, route?: ActivatedRouteSnapshot): boolean;\n    /**\n     * 清空 `closable` 缓存\n     */\n    clearClosableCached(): void;\n    getTruthRoute(route: ActivatedRouteSnapshot): ActivatedRouteSnapshot;\n    /**\n     * 根据快照获取URL地址\n     */\n    getUrl(route: ActivatedRouteSnapshot): string;\n    /**\n     * 检查快照是否允许被复用\n     */\n    can(route: ActivatedRouteSnapshot): boolean;\n    isExclude(url: string): boolean;\n    /**\n     * 刷新，触发一个 refresh 类型事件\n     */\n    refresh(data?: NzSafeAny): void;\n    private destroy;\n    private di;\n    constructor(injector: Injector, menuService: MenuService);\n    init(): void;\n    private getMenu;\n    runHook(method: ReuseHookTypes, comp: ReuseComponentRef | number, type?: ReuseHookOnReuseInitType): void;\n    private hasInValidRoute;\n    /**\n     * 决定是否允许路由复用，若 `true` 会触发 `store`\n     */\n    shouldDetach(route: ActivatedRouteSnapshot): boolean;\n    /**\n     * 存储\n     */\n    store(_snapshot: ActivatedRouteSnapshot, _handle: NzSafeAny): void;\n    /**\n     * 决定是否允许应用缓存数据\n     */\n    shouldAttach(route: ActivatedRouteSnapshot): boolean;\n    /**\n     * 提取复用数据\n     */\n    retrieve(route: ActivatedRouteSnapshot): NzSafeAny | null;\n    /**\n     * 决定是否应该进行复用路由处理\n     */\n    shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n    /**\n     * 获取 `keepingScroll` 状态，顺序如下：\n     *\n     * 1. 路由配置中 data 属性中包含 `keepingScroll`\n     * 2. 菜单数据中 `keepingScroll` 属性\n     * 3. 组件 `keepingScroll` 值\n     */\n    getKeepingScroll(url: string, route?: ActivatedRouteSnapshot): boolean;\n    private get isDisabledInRouter();\n    private get ss();\n    private initScroll;\n    ngOnDestroy(): void;\n}\n"]}
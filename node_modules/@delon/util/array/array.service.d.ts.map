{"version":3,"file":"array.service.d.ts","sources":["array.service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA","sourcesContent":["import { AlainConfigService } from '@delon/util/config';\nimport { NzTreeNode } from 'ng-zorro-antd/core/tree';\nimport { ArrayServiceArrToTreeNodeOptions, ArrayServiceArrToTreeOptions, ArrayServiceGetKeysByTreeNodeOptions, ArrayServiceGroupByResult, ArrayServiceTreeToArrOptions } from './array-type.service';\nexport declare class ArrayService {\n    private c;\n    constructor(cog: AlainConfigService);\n    /**\n     * Convert tree structure to array structure\n     *\n     * 将树结构转换成数组结构\n     */\n    treeToArr<T extends object = any>(tree: readonly T[], options?: ArrayServiceTreeToArrOptions<T>): T[];\n    /**\n     * Convert array structure to tree structure\n     *\n     * 数组转换成树数据\n     */\n    arrToTree<T extends object = any>(arr: readonly T[], options?: ArrayServiceArrToTreeOptions<T>): T[];\n    /**\n     * 数组转换成 `nz-tree` 数据源，通过 `options` 转化项名，也可以使用 `options.cb` 更高级决定数据项\n     */\n    arrToTreeNode<T extends object = any>(arr: readonly T[], options?: ArrayServiceArrToTreeNodeOptions): NzTreeNode[];\n    /**\n     * 递归访问整个树\n     */\n    visitTree<T extends object = any>(tree: readonly T[], cb: (item: T, parent: T | null, deep: number) => void, options?: {\n        /** 子项名，默认：`'children'` */\n        childrenMapName?: string;\n    }): void;\n    /**\n     * Return the value of the first tree value in the tree where predicate is true, and `undefined` otherwise\n     *\n     * 根据条件返回树的第一个值，否则返回 `undefined`\n     */\n    findTree<T extends object = any>(tree: readonly T[], predicate: (item: T) => boolean, options?: {\n        /** 子项名，默认：`'children'` */\n        childrenMapName?: string;\n    }): T | undefined;\n    /**\n     * 获取所有已经选中的 `key` 值\n     */\n    getKeysByTreeNode(tree: NzTreeNode[], options?: ArrayServiceGetKeysByTreeNodeOptions): any[];\n    private baseFlat;\n    /**\n     * Recursively flattens array\n     *\n     * 递归扁平数组\n     * ```ts\n     * srv.flat([1, [2, 3, [4, 5, [6]]]]) => [1,2,3,4,5,6]\n     * srv.flat([1, [2, 3, [4, 5, [6]]]], 1) => [1,2,3,[4, 5, [6]]]\n     * ```\n     */\n    flat<T>(array: readonly T[], depth?: number): T[];\n    /**\n     * Group the array\n     *\n     * 对数组进行分组\n     * ```ts\n     * srv.groupBy([6.1, 4.2, 6.3], Math.floor) => {\"4\":[4.2],\"6\":[6.1,6.3]}\n     * srv.groupBy(['one', 'two', 'three'], v => v.length) => {\"3\":[\"one\",\"two\"],\"5\":[\"three\"]}\n     * ```\n     */\n    groupBy<T>(array: readonly T[], iteratee: (value: T) => string | number): ArrayServiceGroupByResult;\n    /**\n     * Creates a duplicate-free version of an array\n     *\n     * 创建去重后的数组\n     * ```ts\n     * uniq([1, 2, 2, 3, 1]) => [1,2,3]\n     * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], 'a') => [{\"a\":1},{\"a\":2}]\n     * uniq([{ a: 1 }, { a: 1 }, { a: 2 }], i => (i.a === 1 ? 'a' : 'b')) => [{\"a\":1},{\"a\":2}]\n     * ```\n     */\n    uniq<T>(array: readonly T[], predicate?: string | ((value: T) => string | number | boolean)): T[];\n}\n"]}
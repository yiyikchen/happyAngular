import { addDays, endOfDay, endOfMonth, endOfWeek, endOfYear, parse, parseISO, startOfDay, startOfMonth, startOfWeek, startOfYear, subMonths, subWeeks, subYears } from 'date-fns';
/**
 * Get the time range, return `[ Date, Date]` for the start and end dates
 *
 * 获取时间范围
 *
 * @param type 类型，带 `-` 表示过去一个时间，若指定 `number` 表示天数
 * @param time 开始时间
 */
export function getTimeDistance(type, time) {
    time = time
        ? typeof time === 'string'
            ? parse(time, 'yyyy-MM-dd HH:mm:ss', new Date())
            : new Date(time)
        : new Date();
    const options = { weekStartsOn: 1 };
    let res;
    switch (type) {
        case 'today':
            res = [time, time];
            break;
        case '-today':
            res = [addDays(time, -1), time];
            break;
        case 'yesterday':
            res = [addDays(time, -1), addDays(time, -1)];
            break;
        case 'week':
            res = [startOfWeek(time, options), endOfWeek(time, options)];
            break;
        case '-week':
            res = [startOfWeek(subWeeks(time, 1), options), endOfWeek(subWeeks(time, 1), options)];
            break;
        case 'month':
            res = [startOfMonth(time), endOfMonth(time)];
            break;
        case '-month':
            res = [startOfMonth(subMonths(time, 1)), endOfMonth(subMonths(time, 1))];
            break;
        case 'year':
            res = [startOfYear(time), endOfYear(time)];
            break;
        case '-year':
            res = [startOfYear(subYears(time, 1)), endOfYear(subYears(time, 1))];
            break;
        default:
            res = type > 0 ? [time, addDays(time, type)] : [addDays(time, type), time];
            break;
    }
    return fixEndTimeOfRange(res);
}
/**
 * fix time is the most, big value
 */
export function fixEndTimeOfRange(dates) {
    return [startOfDay(dates[0]), endOfDay(dates[1])];
}
/**
 * Return the date parsed from string using the given format string
 * - If the argument is a number, it is treated as a timestamp.
 *
 * @param formatString If parsing fails try to parse the date by pressing `formatString`
 * @param defaultValue If parsing fails returned default value, default: `new Date(NaN)`
 */
export function toDate(value, options) {
    if (typeof options === 'string')
        options = { formatString: options };
    const { formatString, defaultValue } = Object.assign({ formatString: 'yyyy-MM-dd HH:mm:ss', defaultValue: new Date(NaN) }, options);
    if (value == null) {
        return defaultValue;
    }
    if (value instanceof Date) {
        return value;
    }
    if (typeof value === 'number' || (typeof value === 'string' && /[0-9]{10,13}/.test(value))) {
        return new Date(+value);
    }
    let tryDate = parseISO(value);
    if (isNaN(tryDate)) {
        tryDate = parse(value, formatString, new Date());
    }
    return isNaN(tryDate) ? defaultValue : tryDate;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGltZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL3V0aWwvZGF0ZS10aW1lL3RpbWUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLE9BQU8sRUFDUCxRQUFRLEVBQ1IsVUFBVSxFQUNWLFNBQVMsRUFDVCxTQUFTLEVBQ1QsS0FBSyxFQUNMLFFBQVEsRUFDUixVQUFVLEVBQ1YsWUFBWSxFQUNaLFdBQVcsRUFDWCxXQUFXLEVBQ1gsU0FBUyxFQUNULFFBQVEsRUFDUixRQUFRLEVBQ1QsTUFBTSxVQUFVLENBQUM7QUFJbEI7Ozs7Ozs7R0FPRztBQUNILE1BQU0sVUFBVSxlQUFlLENBQzdCLElBQTBHLEVBQzFHLElBQTZCO0lBRTdCLElBQUksR0FBRyxJQUFJO1FBQ1QsQ0FBQyxDQUFDLE9BQU8sSUFBSSxLQUFLLFFBQVE7WUFDeEIsQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUscUJBQXFCLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNoRCxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDO1FBQ2xCLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ2YsTUFBTSxPQUFPLEdBQXdCLEVBQUUsWUFBWSxFQUFFLENBQUMsRUFBRSxDQUFDO0lBRXpELElBQUksR0FBaUIsQ0FBQztJQUN0QixRQUFRLElBQUksRUFBRTtRQUNaLEtBQUssT0FBTztZQUNWLEdBQUcsR0FBRyxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNuQixNQUFNO1FBQ1IsS0FBSyxRQUFRO1lBQ1gsR0FBRyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ2hDLE1BQU07UUFDUixLQUFLLFdBQVc7WUFDZCxHQUFHLEdBQUcsQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVB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S0FBSyxDQUFDLENBQUM7SUFDOUIsSUFBSSxLQUFLLENBQUMsT0FBb0IsQ0FBQyxFQUFFO1FBQy9CLE9BQU8sR0FBRyxLQUFLLENBQUMsS0FBSyxFQUFFLFlBQWEsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7S0FDbkQ7SUFFRCxPQUFPLEtBQUssQ0FBQyxPQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0FBQzlELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBhZGREYXlzLFxuICBlbmRPZkRheSxcbiAgZW5kT2ZNb250aCxcbiAgZW5kT2ZXZWVrLFxuICBlbmRPZlllYXIsXG4gIHBhcnNlLFxuICBwYXJzZUlTTyxcbiAgc3RhcnRPZkRheSxcbiAgc3RhcnRPZk1vbnRoLFxuICBzdGFydE9mV2VlayxcbiAgc3RhcnRPZlllYXIsXG4gIHN1Yk1vbnRocyxcbiAgc3ViV2Vla3MsXG4gIHN1YlllYXJzXG59IGZyb20gJ2RhdGUtZm5zJztcblxuaW1wb3J0IHR5cGUgeyBOelNhZmVBbnkgfSBmcm9tICduZy16b3Jyby1hbnRkL2NvcmUvdHlwZXMnO1xuXG4vKipcbiAqIEdldCB0aGUgdGltZSByYW5nZSwgcmV0dXJuIGBbIERhdGUsIERhdGVdYCBmb3IgdGhlIHN0YXJ0IGFuZCBlbmQgZGF0ZXNcbiAqXG4gKiDojrflj5bml7bpl7TojIPlm7RcbiAqXG4gKiBAcGFyYW0gdHlwZSDnsbvlnovvvIzluKYgYC1gIOihqOekuui/h+WOu+S4gOS4quaXtumXtO+8jOiLpeaMh+WumiBgbnVtYmVyYCDooajnpLrlpKnmlbBcbiAqIEBwYXJhbSB0aW1lIOW8gOWni+aXtumXtFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VGltZURpc3RhbmNlKFxuICB0eXBlOiAndG9kYXknIHwgJy10b2RheScgfCAneWVzdGVyZGF5JyB8ICd3ZWVrJyB8ICctd2VlaycgfCAnbW9udGgnIHwgJy1tb250aCcgfCAneWVhcicgfCAnLXllYXInIHwgbnVtYmVyLFxuICB0aW1lPzogRGF0ZSB8IHN0cmluZyB8IG51bWJlclxuKTogW0RhdGUsIERhdGVdIHtcbiAgdGltZSA9IHRpbWVcbiAgICA/IHR5cGVvZiB0aW1lID09PSAnc3RyaW5nJ1xuICAgICAgPyBwYXJzZSh0aW1lLCAneXl5eS1NTS1kZCBISDptbTpzcycsIG5ldyBEYXRlKCkpXG4gICAgICA6IG5ldyBEYXRlKHRpbWUpXG4gICAgOiBuZXcgRGF0ZSgpO1xuICBjb25zdCBvcHRpb25zOiB7IHdlZWtTdGFydHNPbjogMSB9ID0geyB3ZWVrU3RhcnRzT246IDEgfTtcblxuICBsZXQgcmVzOiBbRGF0ZSwgRGF0ZV07XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3RvZGF5JzpcbiAgICAgIHJlcyA9IFt0aW1lLCB0aW1lXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJy10b2RheSc6XG4gICAgICByZXMgPSBbYWRkRGF5cyh0aW1lLCAtMSksIHRpbWVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAneWVzdGVyZGF5JzpcbiAgICAgIHJlcyA9IFthZGREYXlzKHRpbWUsIC0xKSwgYWRkRGF5cyh0aW1lLCAtMSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICByZXMgPSBbc3RhcnRPZldlZWsodGltZSwgb3B0aW9ucyksIGVuZE9mV2Vlayh0aW1lLCBvcHRpb25zKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICctd2Vlayc6XG4gICAgICByZXMgPSBbc3RhcnRPZldlZWsoc3ViV2Vla3ModGltZSwgMSksIG9wdGlvbnMpLCBlbmRPZldlZWsoc3ViV2Vla3ModGltZSwgMSksIG9wdGlvbnMpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJlcyA9IFtzdGFydE9mTW9udGgodGltZSksIGVuZE9mTW9udGgodGltZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLW1vbnRoJzpcbiAgICAgIHJlcyA9IFtzdGFydE9mTW9udGgoc3ViTW9udGhzKHRpbWUsIDEpKSwgZW5kT2ZNb250aChzdWJNb250aHModGltZSwgMSkpXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgcmVzID0gW3N0YXJ0T2ZZZWFyKHRpbWUpLCBlbmRPZlllYXIodGltZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLXllYXInOlxuICAgICAgcmVzID0gW3N0YXJ0T2ZZZWFyKHN1YlllYXJzKHRpbWUsIDEpKSwgZW5kT2ZZZWFyKHN1YlllYXJzKHRpbWUsIDEpKV07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmVzID0gdHlwZSA+IDAgPyBbdGltZSwgYWRkRGF5cyh0aW1lLCB0eXBlKV0gOiBbYWRkRGF5cyh0aW1lLCB0eXBlKSwgdGltZV07XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gZml4RW5kVGltZU9mUmFuZ2UocmVzKTtcbn1cblxuLyoqXG4gKiBmaXggdGltZSBpcyB0aGUgbW9zdCwgYmlnIHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaXhFbmRUaW1lT2ZSYW5nZShkYXRlczogW0RhdGUsIERhdGVdKTogW0RhdGUsIERhdGVdIHtcbiAgcmV0dXJuIFtzdGFydE9mRGF5KGRhdGVzWzBdKSwgZW5kT2ZEYXkoZGF0ZXNbMV0pXTtcbn1cblxuZXhwb3J0IHR5cGUgVG9EYXRlT3B0aW9ucyA9IHN0cmluZyB8IHsgZm9ybWF0U3RyaW5nPzogc3RyaW5nOyBkZWZhdWx0VmFsdWU/OiBOelNhZmVBbnkgfTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGRhdGUgcGFyc2VkIGZyb20gc3RyaW5nIHVzaW5nIHRoZSBnaXZlbiBmb3JtYXQgc3RyaW5nXG4gKiAtIElmIHRoZSBhcmd1bWVudCBpcyBhIG51bWJlciwgaXQgaXMgdHJlYXRlZCBhcyBhIHRpbWVzdGFtcC5cbiAqXG4gKiBAcGFyYW0gZm9ybWF0U3RyaW5nIElmIHBhcnNpbmcgZmFpbHMgdHJ5IHRvIHBhcnNlIHRoZSBkYXRlIGJ5IHByZXNzaW5nIGBmb3JtYXRTdHJpbmdgXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIElmIHBhcnNpbmcgZmFpbHMgcmV0dXJuZWQgZGVmYXVsdCB2YWx1ZSwgZGVmYXVsdDogYG5ldyBEYXRlKE5hTilgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RhdGUodmFsdWU6IERhdGUgfCBzdHJpbmcgfCBudW1iZXIsIG9wdGlvbnM/OiBUb0RhdGVPcHRpb25zKTogRGF0ZSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIG9wdGlvbnMgPSB7IGZvcm1hdFN0cmluZzogb3B0aW9ucyB9O1xuICBjb25zdCB7IGZvcm1hdFN0cmluZywgZGVmYXVsdFZhbHVlIH0gPSB7XG4gICAgZm9ybWF0U3RyaW5nOiAneXl5eS1NTS1kZCBISDptbTpzcycsXG4gICAgZGVmYXVsdFZhbHVlOiBuZXcgRGF0ZShOYU4pLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgL1swLTldezEwLDEzfS8udGVzdCh2YWx1ZSkpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCt2YWx1ZSk7XG4gIH1cbiAgbGV0IHRyeURhdGUgPSBwYXJzZUlTTyh2YWx1ZSk7XG4gIGlmIChpc05hTih0cnlEYXRlIGFzIE56U2FmZUFueSkpIHtcbiAgICB0cnlEYXRlID0gcGFyc2UodmFsdWUsIGZvcm1hdFN0cmluZyEsIG5ldyBEYXRlKCkpO1xuICB9XG5cbiAgcmV0dXJuIGlzTmFOKHRyeURhdGUgYXMgTnpTYWZlQW55KSA/IGRlZmF1bHRWYWx1ZSA6IHRyeURhdGU7XG59XG4iXX0=
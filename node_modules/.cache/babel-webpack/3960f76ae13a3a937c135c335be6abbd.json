{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst validation_error_1 = require(\"../runtime/validation_error\");\n\nconst names_1 = require(\"./names\");\n\nconst resolve_1 = require(\"./resolve\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n\nconst URI = require(\"uri-js\");\n\nclass SchemaEnv {\n  constructor(env) {\n    var _a;\n\n    this.refs = {};\n    this.dynamicAnchors = {};\n    let schema;\n    if (typeof env.schema == \"object\") schema = env.schema;\n    this.schema = env.schema;\n    this.schemaId = env.schemaId;\n    this.root = env.root || this;\n    this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n    this.schemaPath = env.schemaPath;\n    this.localRefs = env.localRefs;\n    this.meta = env.meta;\n    this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n    this.refs = {};\n  }\n\n}\n\nexports.SchemaEnv = SchemaEnv; // let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\n\nfunction compileSchema(sch) {\n  // TODO refactor - remove compilations\n  const _sch = getCompilingSchema.call(this, sch);\n\n  if (_sch) return _sch;\n  const rootId = resolve_1.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n\n  const {\n    es5,\n    lines\n  } = this.opts.code;\n  const {\n    ownProperties\n  } = this.opts;\n  const gen = new codegen_1.CodeGen(this.scope, {\n    es5,\n    lines,\n    ownProperties\n  });\n\n  let _ValidationError;\n\n  if (sch.$async) {\n    _ValidationError = gen.scopeValue(\"Error\", {\n      ref: validation_error_1.default,\n      code: codegen_1._`require(\"ajv/dist/runtime/validation_error\").default`\n    });\n  }\n\n  const validateName = gen.scopeName(\"validate\");\n  sch.validateName = validateName;\n  const schemaCxt = {\n    gen,\n    allErrors: this.opts.allErrors,\n    data: names_1.default.data,\n    parentData: names_1.default.parentData,\n    parentDataProperty: names_1.default.parentDataProperty,\n    dataNames: [names_1.default.data],\n    dataPathArr: [codegen_1.nil],\n    dataLevel: 0,\n    dataTypes: [],\n    definedProperties: new Set(),\n    topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true ? {\n      ref: sch.schema,\n      code: codegen_1.stringify(sch.schema)\n    } : {\n      ref: sch.schema\n    }),\n    validateName,\n    ValidationError: _ValidationError,\n    schema: sch.schema,\n    schemaEnv: sch,\n    rootId,\n    baseId: sch.baseId || rootId,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n    errorPath: codegen_1._`\"\"`,\n    opts: this.opts,\n    self: this\n  };\n  let sourceCode;\n\n  try {\n    this._compilations.add(sch);\n\n    validate_1.validateFunctionCode(schemaCxt);\n    gen.optimize(this.opts.code.optimize); // gen.optimize(1)\n\n    const validateCode = gen.toString();\n    sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`; // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n\n    if (this.opts.code.process) sourceCode = this.opts.code.process(sourceCode, sch); // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n\n    const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n    const validate = makeValidate(this, this.scope.get());\n    this.scope.value(validateName, {\n      ref: validate\n    });\n    validate.errors = null;\n    validate.schema = sch.schema;\n    validate.schemaEnv = sch;\n    if (sch.$async) validate.$async = true;\n\n    if (this.opts.code.source === true) {\n      validate.source = {\n        validateName,\n        validateCode,\n        scopeValues: gen._values\n      };\n    }\n\n    if (this.opts.unevaluated) {\n      const {\n        props,\n        items\n      } = schemaCxt;\n      validate.evaluated = {\n        props: props instanceof codegen_1.Name ? undefined : props,\n        items: items instanceof codegen_1.Name ? undefined : items,\n        dynamicProps: props instanceof codegen_1.Name,\n        dynamicItems: items instanceof codegen_1.Name\n      };\n      if (validate.source) validate.source.evaluated = codegen_1.stringify(validate.evaluated);\n    }\n\n    sch.validate = validate;\n    return sch;\n  } catch (e) {\n    delete sch.validate;\n    delete sch.validateName;\n    if (sourceCode) this.logger.error(\"Error compiling schema, function code:\", sourceCode); // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n\n    throw e;\n  } finally {\n    this._compilations.delete(sch);\n  }\n}\n\nexports.compileSchema = compileSchema;\n\nfunction resolveRef(root, baseId, ref) {\n  var _a;\n\n  ref = resolve_1.resolveUrl(baseId, ref);\n  const schOrFunc = root.refs[ref];\n  if (schOrFunc) return schOrFunc;\n\n  let _sch = resolve.call(this, root, ref);\n\n  if (_sch === undefined) {\n    const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n\n    const {\n      schemaId\n    } = this.opts;\n    if (schema) _sch = new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  if (_sch === undefined) return;\n  return root.refs[ref] = inlineOrCompile.call(this, _sch);\n}\n\nexports.resolveRef = resolveRef;\n\nfunction inlineOrCompile(sch) {\n  if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs)) return sch.schema;\n  return sch.validate ? sch : compileSchema.call(this, sch);\n} // Index of schema compilation in the currently compiled list\n\n\nfunction getCompilingSchema(schEnv) {\n  for (const sch of this._compilations) {\n    if (sameSchemaEnv(sch, schEnv)) return sch;\n  }\n}\n\nexports.getCompilingSchema = getCompilingSchema;\n\nfunction sameSchemaEnv(s1, s2) {\n  return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n} // resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\n\n\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n  let sch;\n\n  while (typeof (sch = this.refs[ref]) == \"string\") ref = sch;\n\n  return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n} // Resolve schema, its root and baseId\n\n\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n  const p = URI.parse(ref);\n\n  const refPath = resolve_1._getFullPath(p);\n\n  let baseId = resolve_1.getFullPath(root.baseId); // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n\n  if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n    return getJsonPointer.call(this, p, root);\n  }\n\n  const id = resolve_1.normalizeId(refPath);\n  const schOrRef = this.refs[id] || this.schemas[id];\n\n  if (typeof schOrRef == \"string\") {\n    const sch = resolveSchema.call(this, root, schOrRef);\n    if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\") return;\n    return getJsonPointer.call(this, p, sch);\n  }\n\n  if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\") return;\n  if (!schOrRef.validate) compileSchema.call(this, schOrRef);\n\n  if (id === resolve_1.normalizeId(ref)) {\n    const {\n      schema\n    } = schOrRef;\n    const {\n      schemaId\n    } = this.opts;\n    const schId = schema[schemaId];\n    if (schId) baseId = resolve_1.resolveUrl(baseId, schId);\n    return new SchemaEnv({\n      schema,\n      schemaId,\n      root,\n      baseId\n    });\n  }\n\n  return getJsonPointer.call(this, p, schOrRef);\n}\n\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\"properties\", \"patternProperties\", \"enum\", \"dependencies\", \"definitions\"]);\n\nfunction getJsonPointer(parsedRef, {\n  baseId,\n  schema,\n  root\n}) {\n  var _a;\n\n  if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\") return;\n\n  for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n    if (typeof schema == \"boolean\") return;\n    schema = schema[util_1.unescapeFragment(part)];\n    if (schema === undefined) return; // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n\n    const schId = typeof schema == \"object\" && schema[this.opts.schemaId];\n\n    if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n      baseId = resolve_1.resolveUrl(baseId, schId);\n    }\n  }\n\n  let env;\n\n  if (typeof schema != \"boolean\" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {\n    const $ref = resolve_1.resolveUrl(baseId, schema.$ref);\n    env = resolveSchema.call(this, root, $ref);\n  } // even though resolution failed we need to return SchemaEnv to throw exception\n  // so that compileAsync loads missing schema.\n\n\n  const {\n    schemaId\n  } = this.opts;\n  env = env || new SchemaEnv({\n    schema,\n    schemaId,\n    root,\n    baseId\n  });\n  if (env.schema !== env.root.schema) return env;\n  return undefined;\n}","map":{"version":3,"sources":["D:/happyAngular/node_modules/ajv/dist/compile/index.js"],"names":["Object","defineProperty","exports","value","resolveSchema","getCompilingSchema","resolveRef","compileSchema","SchemaEnv","codegen_1","require","validation_error_1","names_1","resolve_1","util_1","validate_1","URI","constructor","env","_a","refs","dynamicAnchors","schema","schemaId","root","baseId","normalizeId","schemaPath","localRefs","meta","$async","sch","_sch","call","rootId","getFullPath","es5","lines","opts","code","ownProperties","gen","CodeGen","scope","_ValidationError","scopeValue","ref","default","_","validateName","scopeName","schemaCxt","allErrors","data","parentData","parentDataProperty","dataNames","dataPathArr","nil","dataLevel","dataTypes","definedProperties","Set","topSchemaRef","source","stringify","ValidationError","schemaEnv","errSchemaPath","jtd","errorPath","self","sourceCode","_compilations","add","validateFunctionCode","optimize","validateCode","toString","scopeRefs","process","makeValidate","Function","validate","get","errors","scopeValues","_values","unevaluated","props","items","evaluated","Name","undefined","dynamicProps","dynamicItems","e","logger","error","delete","resolveUrl","schOrFunc","resolve","inlineOrCompile","inlineRef","inlineRefs","schEnv","sameSchemaEnv","s1","s2","schemas","p","parse","refPath","_getFullPath","keys","length","getJsonPointer","id","schOrRef","schId","PREVENT_SCOPE_CHANGE","parsedRef","fragment","part","slice","split","unescapeFragment","has","$ref","schemaHasRulesButRef","RULES"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst validation_error_1 = require(\"../runtime/validation_error\");\nconst names_1 = require(\"./names\");\nconst resolve_1 = require(\"./resolve\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst URI = require(\"uri-js\");\nclass SchemaEnv {\n    constructor(env) {\n        var _a;\n        this.refs = {};\n        this.dynamicAnchors = {};\n        let schema;\n        if (typeof env.schema == \"object\")\n            schema = env.schema;\n        this.schema = env.schema;\n        this.schemaId = env.schemaId;\n        this.root = env.root || this;\n        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : resolve_1.normalizeId(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || \"$id\"]);\n        this.schemaPath = env.schemaPath;\n        this.localRefs = env.localRefs;\n        this.meta = env.meta;\n        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;\n        this.refs = {};\n    }\n}\nexports.SchemaEnv = SchemaEnv;\n// let codeSize = 0\n// let nodeCount = 0\n// Compiles schema in SchemaEnv\nfunction compileSchema(sch) {\n    // TODO refactor - remove compilations\n    const _sch = getCompilingSchema.call(this, sch);\n    if (_sch)\n        return _sch;\n    const rootId = resolve_1.getFullPath(sch.root.baseId); // TODO if getFullPath removed 1 tests fails\n    const { es5, lines } = this.opts.code;\n    const { ownProperties } = this.opts;\n    const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });\n    let _ValidationError;\n    if (sch.$async) {\n        _ValidationError = gen.scopeValue(\"Error\", {\n            ref: validation_error_1.default,\n            code: codegen_1._ `require(\"ajv/dist/runtime/validation_error\").default`,\n        });\n    }\n    const validateName = gen.scopeName(\"validate\");\n    sch.validateName = validateName;\n    const schemaCxt = {\n        gen,\n        allErrors: this.opts.allErrors,\n        data: names_1.default.data,\n        parentData: names_1.default.parentData,\n        parentDataProperty: names_1.default.parentDataProperty,\n        dataNames: [names_1.default.data],\n        dataPathArr: [codegen_1.nil],\n        dataLevel: 0,\n        dataTypes: [],\n        definedProperties: new Set(),\n        topSchemaRef: gen.scopeValue(\"schema\", this.opts.code.source === true\n            ? { ref: sch.schema, code: codegen_1.stringify(sch.schema) }\n            : { ref: sch.schema }),\n        validateName,\n        ValidationError: _ValidationError,\n        schema: sch.schema,\n        schemaEnv: sch,\n        rootId,\n        baseId: sch.baseId || rootId,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: sch.schemaPath || (this.opts.jtd ? \"\" : \"#\"),\n        errorPath: codegen_1._ `\"\"`,\n        opts: this.opts,\n        self: this,\n    };\n    let sourceCode;\n    try {\n        this._compilations.add(sch);\n        validate_1.validateFunctionCode(schemaCxt);\n        gen.optimize(this.opts.code.optimize);\n        // gen.optimize(1)\n        const validateCode = gen.toString();\n        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;\n        // console.log((codeSize += sourceCode.length), (nodeCount += gen.nodeCount))\n        if (this.opts.code.process)\n            sourceCode = this.opts.code.process(sourceCode, sch);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode)\n        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);\n        const validate = makeValidate(this, this.scope.get());\n        this.scope.value(validateName, { ref: validate });\n        validate.errors = null;\n        validate.schema = sch.schema;\n        validate.schemaEnv = sch;\n        if (sch.$async)\n            validate.$async = true;\n        if (this.opts.code.source === true) {\n            validate.source = { validateName, validateCode, scopeValues: gen._values };\n        }\n        if (this.opts.unevaluated) {\n            const { props, items } = schemaCxt;\n            validate.evaluated = {\n                props: props instanceof codegen_1.Name ? undefined : props,\n                items: items instanceof codegen_1.Name ? undefined : items,\n                dynamicProps: props instanceof codegen_1.Name,\n                dynamicItems: items instanceof codegen_1.Name,\n            };\n            if (validate.source)\n                validate.source.evaluated = codegen_1.stringify(validate.evaluated);\n        }\n        sch.validate = validate;\n        return sch;\n    }\n    catch (e) {\n        delete sch.validate;\n        delete sch.validateName;\n        if (sourceCode)\n            this.logger.error(\"Error compiling schema, function code:\", sourceCode);\n        // console.log(\"\\n\\n\\n *** \\n\", sourceCode, this.opts)\n        throw e;\n    }\n    finally {\n        this._compilations.delete(sch);\n    }\n}\nexports.compileSchema = compileSchema;\nfunction resolveRef(root, baseId, ref) {\n    var _a;\n    ref = resolve_1.resolveUrl(baseId, ref);\n    const schOrFunc = root.refs[ref];\n    if (schOrFunc)\n        return schOrFunc;\n    let _sch = resolve.call(this, root, ref);\n    if (_sch === undefined) {\n        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref]; // TODO maybe localRefs should hold SchemaEnv\n        const { schemaId } = this.opts;\n        if (schema)\n            _sch = new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    if (_sch === undefined)\n        return;\n    return (root.refs[ref] = inlineOrCompile.call(this, _sch));\n}\nexports.resolveRef = resolveRef;\nfunction inlineOrCompile(sch) {\n    if (resolve_1.inlineRef(sch.schema, this.opts.inlineRefs))\n        return sch.schema;\n    return sch.validate ? sch : compileSchema.call(this, sch);\n}\n// Index of schema compilation in the currently compiled list\nfunction getCompilingSchema(schEnv) {\n    for (const sch of this._compilations) {\n        if (sameSchemaEnv(sch, schEnv))\n            return sch;\n    }\n}\nexports.getCompilingSchema = getCompilingSchema;\nfunction sameSchemaEnv(s1, s2) {\n    return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;\n}\n// resolve and compile the references ($ref)\n// TODO returns AnySchemaObject (if the schema can be inlined) or validation function\nfunction resolve(root, // information about the root schema for the current schema\nref // reference to resolve\n) {\n    let sch;\n    while (typeof (sch = this.refs[ref]) == \"string\")\n        ref = sch;\n    return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);\n}\n// Resolve schema, its root and baseId\nfunction resolveSchema(root, // root object with properties schema, refs TODO below SchemaEnv is assigned to it\nref // reference to resolve\n) {\n    const p = URI.parse(ref);\n    const refPath = resolve_1._getFullPath(p);\n    let baseId = resolve_1.getFullPath(root.baseId);\n    // TODO `Object.keys(root.schema).length > 0` should not be needed - but removing breaks 2 tests\n    if (Object.keys(root.schema).length > 0 && refPath === baseId) {\n        return getJsonPointer.call(this, p, root);\n    }\n    const id = resolve_1.normalizeId(refPath);\n    const schOrRef = this.refs[id] || this.schemas[id];\n    if (typeof schOrRef == \"string\") {\n        const sch = resolveSchema.call(this, root, schOrRef);\n        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== \"object\")\n            return;\n        return getJsonPointer.call(this, p, sch);\n    }\n    if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== \"object\")\n        return;\n    if (!schOrRef.validate)\n        compileSchema.call(this, schOrRef);\n    if (id === resolve_1.normalizeId(ref)) {\n        const { schema } = schOrRef;\n        const { schemaId } = this.opts;\n        const schId = schema[schemaId];\n        if (schId)\n            baseId = resolve_1.resolveUrl(baseId, schId);\n        return new SchemaEnv({ schema, schemaId, root, baseId });\n    }\n    return getJsonPointer.call(this, p, schOrRef);\n}\nexports.resolveSchema = resolveSchema;\nconst PREVENT_SCOPE_CHANGE = new Set([\n    \"properties\",\n    \"patternProperties\",\n    \"enum\",\n    \"dependencies\",\n    \"definitions\",\n]);\nfunction getJsonPointer(parsedRef, { baseId, schema, root }) {\n    var _a;\n    if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== \"/\")\n        return;\n    for (const part of parsedRef.fragment.slice(1).split(\"/\")) {\n        if (typeof schema == \"boolean\")\n            return;\n        schema = schema[util_1.unescapeFragment(part)];\n        if (schema === undefined)\n            return;\n        // TODO PREVENT_SCOPE_CHANGE could be defined in keyword def?\n        const schId = typeof schema == \"object\" && schema[this.opts.schemaId];\n        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {\n            baseId = resolve_1.resolveUrl(baseId, schId);\n        }\n    }\n    let env;\n    if (typeof schema != \"boolean\" && schema.$ref && !util_1.schemaHasRulesButRef(schema, this.RULES)) {\n        const $ref = resolve_1.resolveUrl(baseId, schema.$ref);\n        env = resolveSchema.call(this, root, $ref);\n    }\n    // even though resolution failed we need to return SchemaEnv to throw exception\n    // so that compileAsync loads missing schema.\n    const { schemaId } = this.opts;\n    env = env || new SchemaEnv({ schema, schemaId, root, baseId });\n    if (env.schema !== env.root.schema)\n        return env;\n    return undefined;\n}\n"]},"metadata":{},"sourceType":"script"}
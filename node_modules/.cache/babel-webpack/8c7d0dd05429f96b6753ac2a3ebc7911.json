{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst code_1 = require(\"../../vocabularies/code\");\n\nconst errors_1 = require(\"../errors\");\n\nfunction macroKeywordCode(cxt, def) {\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    it\n  } = cxt;\n  const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n  const schemaRef = useKeyword(gen, keyword, macroSchema);\n  if (it.opts.validateSchema !== false) it.self.validateSchema(macroSchema, true);\n  const valid = gen.name(\"valid\");\n  cxt.subschema({\n    schema: macroSchema,\n    schemaPath: codegen_1.nil,\n    errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n    topSchemaRef: schemaRef,\n    compositeRule: true\n  }, valid);\n  cxt.pass(valid, () => cxt.error(true));\n}\n\nexports.macroKeywordCode = macroKeywordCode;\n\nfunction funcKeywordCode(cxt, def) {\n  var _a;\n\n  const {\n    gen,\n    keyword,\n    schema,\n    parentSchema,\n    $data,\n    it\n  } = cxt;\n  checkAsyncKeyword(it, def);\n  const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n  const validateRef = useKeyword(gen, keyword, validate);\n  const valid = gen.let(\"valid\");\n  cxt.block$data(valid, validateKeyword);\n  cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n\n  function validateKeyword() {\n    if (def.errors === false) {\n      assignValid();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => cxt.error());\n    } else {\n      const ruleErrs = def.async ? validateAsync() : validateSync();\n      if (def.modifying) modifyData(cxt);\n      reportErrs(() => addErrs(cxt, ruleErrs));\n    }\n  }\n\n  function validateAsync() {\n    const ruleErrs = gen.let(\"ruleErrs\", null);\n    gen.try(() => assignValid(codegen_1._`await `), e => gen.assign(valid, false).if(codegen_1._`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._`${e}.errors`), () => gen.throw(e)));\n    return ruleErrs;\n  }\n\n  function validateSync() {\n    const validateErrs = codegen_1._`${validateRef}.errors`;\n    gen.assign(validateErrs, null);\n    assignValid(codegen_1.nil);\n    return validateErrs;\n  }\n\n  function assignValid(_await = def.async ? codegen_1._`await ` : codegen_1.nil) {\n    const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n    const passSchema = !(\"compile\" in def && !$data || def.schema === false);\n    gen.assign(valid, codegen_1._`${_await}${code_1.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n  }\n\n  function reportErrs(errors) {\n    var _a;\n\n    gen.if(codegen_1.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n  }\n}\n\nexports.funcKeywordCode = funcKeywordCode;\n\nfunction modifyData(cxt) {\n  const {\n    gen,\n    data,\n    it\n  } = cxt;\n  gen.if(it.parentData, () => gen.assign(data, codegen_1._`${it.parentData}[${it.parentDataProperty}]`));\n}\n\nfunction addErrs(cxt, errs) {\n  const {\n    gen\n  } = cxt;\n  gen.if(codegen_1._`Array.isArray(${errs})`, () => {\n    gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);\n    errors_1.extendErrors(cxt);\n  }, () => cxt.error());\n}\n\nfunction checkAsyncKeyword({\n  schemaEnv\n}, def) {\n  if (def.async && !schemaEnv.$async) throw new Error(\"async keyword in sync schema\");\n}\n\nfunction useKeyword(gen, keyword, result) {\n  if (result === undefined) throw new Error(`keyword \"${keyword}\" failed to compile`);\n  return gen.scopeValue(\"keyword\", typeof result == \"function\" ? {\n    ref: result\n  } : {\n    ref: result,\n    code: codegen_1.stringify(result)\n  });\n}\n\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n  // TODO add tests\n  return !schemaType.length || schemaType.some(st => st === \"array\" ? Array.isArray(schema) : st === \"object\" ? schema && typeof schema == \"object\" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == \"undefined\");\n}\n\nexports.validSchemaType = validSchemaType;\n\nfunction validateKeywordUsage({\n  schema,\n  opts,\n  self,\n  errSchemaPath\n}, def, keyword) {\n  /* istanbul ignore if */\n  if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n    throw new Error(\"ajv implementation error\");\n  }\n\n  const deps = def.dependencies;\n\n  if (deps === null || deps === void 0 ? void 0 : deps.some(kwd => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n    throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n  }\n\n  if (def.validateSchema) {\n    const valid = def.validateSchema(schema[keyword]);\n\n    if (!valid) {\n      const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` + self.errorsText(def.validateSchema.errors);\n      if (opts.validateSchema === \"log\") self.logger.error(msg);else throw new Error(msg);\n    }\n  }\n}\n\nexports.validateKeywordUsage = validateKeywordUsage;","map":{"version":3,"sources":["D:/happyAngular/node_modules/ajv/dist/compile/validate/keyword.js"],"names":["Object","defineProperty","exports","value","validateKeywordUsage","validSchemaType","funcKeywordCode","macroKeywordCode","codegen_1","require","names_1","code_1","errors_1","cxt","def","gen","keyword","schema","parentSchema","it","macroSchema","macro","call","self","schemaRef","useKeyword","opts","validateSchema","valid","name","subschema","schemaPath","nil","errSchemaPath","topSchemaRef","compositeRule","pass","error","_a","$data","checkAsyncKeyword","validate","compile","validateRef","let","block$data","validateKeyword","ok","errors","assignValid","modifying","modifyData","reportErrs","ruleErrs","async","validateAsync","validateSync","addErrs","try","_","e","assign","if","ValidationError","throw","validateErrs","_await","passCxt","passContext","default","this","passSchema","callValidateCode","not","data","parentData","parentDataProperty","errs","vErrors","extendErrors","schemaEnv","$async","Error","result","undefined","scopeValue","ref","code","stringify","schemaType","allowUndefined","length","some","st","Array","isArray","includes","deps","dependencies","kwd","prototype","hasOwnProperty","join","msg","errorsText","logger"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst code_1 = require(\"../../vocabularies/code\");\nconst errors_1 = require(\"../errors\");\nfunction macroKeywordCode(cxt, def) {\n    const { gen, keyword, schema, parentSchema, it } = cxt;\n    const macroSchema = def.macro.call(it.self, schema, parentSchema, it);\n    const schemaRef = useKeyword(gen, keyword, macroSchema);\n    if (it.opts.validateSchema !== false)\n        it.self.validateSchema(macroSchema, true);\n    const valid = gen.name(\"valid\");\n    cxt.subschema({\n        schema: macroSchema,\n        schemaPath: codegen_1.nil,\n        errSchemaPath: `${it.errSchemaPath}/${keyword}`,\n        topSchemaRef: schemaRef,\n        compositeRule: true,\n    }, valid);\n    cxt.pass(valid, () => cxt.error(true));\n}\nexports.macroKeywordCode = macroKeywordCode;\nfunction funcKeywordCode(cxt, def) {\n    var _a;\n    const { gen, keyword, schema, parentSchema, $data, it } = cxt;\n    checkAsyncKeyword(it, def);\n    const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;\n    const validateRef = useKeyword(gen, keyword, validate);\n    const valid = gen.let(\"valid\");\n    cxt.block$data(valid, validateKeyword);\n    cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);\n    function validateKeyword() {\n        if (def.errors === false) {\n            assignValid();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => cxt.error());\n        }\n        else {\n            const ruleErrs = def.async ? validateAsync() : validateSync();\n            if (def.modifying)\n                modifyData(cxt);\n            reportErrs(() => addErrs(cxt, ruleErrs));\n        }\n    }\n    function validateAsync() {\n        const ruleErrs = gen.let(\"ruleErrs\", null);\n        gen.try(() => assignValid(codegen_1._ `await `), (e) => gen.assign(valid, false).if(codegen_1._ `${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, codegen_1._ `${e}.errors`), () => gen.throw(e)));\n        return ruleErrs;\n    }\n    function validateSync() {\n        const validateErrs = codegen_1._ `${validateRef}.errors`;\n        gen.assign(validateErrs, null);\n        assignValid(codegen_1.nil);\n        return validateErrs;\n    }\n    function assignValid(_await = def.async ? codegen_1._ `await ` : codegen_1.nil) {\n        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;\n        const passSchema = !((\"compile\" in def && !$data) || def.schema === false);\n        gen.assign(valid, codegen_1._ `${_await}${code_1.callValidateCode(cxt, validateRef, passCxt, passSchema)}`, def.modifying);\n    }\n    function reportErrs(errors) {\n        var _a;\n        gen.if(codegen_1.not((_a = def.valid) !== null && _a !== void 0 ? _a : valid), errors);\n    }\n}\nexports.funcKeywordCode = funcKeywordCode;\nfunction modifyData(cxt) {\n    const { gen, data, it } = cxt;\n    gen.if(it.parentData, () => gen.assign(data, codegen_1._ `${it.parentData}[${it.parentDataProperty}]`));\n}\nfunction addErrs(cxt, errs) {\n    const { gen } = cxt;\n    gen.if(codegen_1._ `Array.isArray(${errs})`, () => {\n        gen\n            .assign(names_1.default.vErrors, codegen_1._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`)\n            .assign(names_1.default.errors, codegen_1._ `${names_1.default.vErrors}.length`);\n        errors_1.extendErrors(cxt);\n    }, () => cxt.error());\n}\nfunction checkAsyncKeyword({ schemaEnv }, def) {\n    if (def.async && !schemaEnv.$async)\n        throw new Error(\"async keyword in sync schema\");\n}\nfunction useKeyword(gen, keyword, result) {\n    if (result === undefined)\n        throw new Error(`keyword \"${keyword}\" failed to compile`);\n    return gen.scopeValue(\"keyword\", typeof result == \"function\" ? { ref: result } : { ref: result, code: codegen_1.stringify(result) });\n}\nfunction validSchemaType(schema, schemaType, allowUndefined = false) {\n    // TODO add tests\n    return (!schemaType.length ||\n        schemaType.some((st) => st === \"array\"\n            ? Array.isArray(schema)\n            : st === \"object\"\n                ? schema && typeof schema == \"object\" && !Array.isArray(schema)\n                : typeof schema == st || (allowUndefined && typeof schema == \"undefined\")));\n}\nexports.validSchemaType = validSchemaType;\nfunction validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {\n    /* istanbul ignore if */\n    if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {\n        throw new Error(\"ajv implementation error\");\n    }\n    const deps = def.dependencies;\n    if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {\n        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(\",\")}`);\n    }\n    if (def.validateSchema) {\n        const valid = def.validateSchema(schema[keyword]);\n        if (!valid) {\n            const msg = `keyword \"${keyword}\" value is invalid at path \"${errSchemaPath}\": ` +\n                self.errorsText(def.validateSchema.errors);\n            if (opts.validateSchema === \"log\")\n                self.logger.error(msg);\n            else\n                throw new Error(msg);\n        }\n    }\n}\nexports.validateKeywordUsage = validateKeywordUsage;\n"]},"metadata":{},"sourceType":"script"}
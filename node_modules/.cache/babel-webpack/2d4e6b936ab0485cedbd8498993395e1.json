{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst error = {\n  message: ({\n    schemaCode\n  }) => codegen_1.str`must match format \"${schemaCode}\"`,\n  params: ({\n    schemaCode\n  }) => codegen_1._`{format: ${schemaCode}}`\n};\nconst def = {\n  keyword: \"format\",\n  type: [\"number\", \"string\"],\n  schemaType: \"string\",\n  $data: true,\n  error,\n\n  code(cxt, ruleType) {\n    const {\n      gen,\n      data,\n      $data,\n      schema,\n      schemaCode,\n      it\n    } = cxt;\n    const {\n      opts,\n      errSchemaPath,\n      schemaEnv,\n      self\n    } = it;\n    if (!opts.validateFormats) return;\n    if ($data) validate$DataFormat();else validateFormat();\n\n    function validate$DataFormat() {\n      const fmts = gen.scopeValue(\"formats\", {\n        ref: self.formats,\n        code: opts.code.formats\n      });\n      const fDef = gen.const(\"fDef\", codegen_1._`${fmts}[${schemaCode}]`);\n      const fType = gen.let(\"fType\");\n      const format = gen.let(\"format\"); // TODO simplify\n\n      gen.if(codegen_1._`typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1._`${fDef}.type || \"string\"`).assign(format, codegen_1._`${fDef}.validate`), () => gen.assign(fType, codegen_1._`\"string\"`).assign(format, fDef));\n      cxt.fail$data(codegen_1.or(unknownFmt(), invalidFmt()));\n\n      function unknownFmt() {\n        if (opts.strictSchema === false) return codegen_1.nil;\n        return codegen_1._`${schemaCode} && !${format}`;\n      }\n\n      function invalidFmt() {\n        const callFormat = schemaEnv.$async ? codegen_1._`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : codegen_1._`${format}(${data})`;\n        const validData = codegen_1._`(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n        return codegen_1._`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n      }\n    }\n\n    function validateFormat() {\n      const formatDef = self.formats[schema];\n\n      if (!formatDef) {\n        unknownFormat();\n        return;\n      }\n\n      if (formatDef === true) return;\n      const [fmtType, format, fmtRef] = getFormat(formatDef);\n      if (fmtType === ruleType) cxt.pass(validCondition());\n\n      function unknownFormat() {\n        if (opts.strictSchema === false) {\n          self.logger.warn(unknownMsg());\n          return;\n        }\n\n        throw new Error(unknownMsg());\n\n        function unknownMsg() {\n          return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n        }\n      }\n\n      function getFormat(fmtDef) {\n        const code = fmtDef instanceof RegExp ? codegen_1.regexpCode(fmtDef) : opts.code.formats ? codegen_1._`${opts.code.formats}${codegen_1.getProperty(schema)}` : undefined;\n        const fmt = gen.scopeValue(\"formats\", {\n          key: schema,\n          ref: fmtDef,\n          code\n        });\n\n        if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n          return [fmtDef.type || \"string\", fmtDef.validate, codegen_1._`${fmt}.validate`];\n        }\n\n        return [\"string\", fmtDef, fmt];\n      }\n\n      function validCondition() {\n        if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n          if (!schemaEnv.$async) throw new Error(\"async format in sync schema\");\n          return codegen_1._`await ${fmtRef}(${data})`;\n        }\n\n        return typeof format == \"function\" ? codegen_1._`${fmtRef}(${data})` : codegen_1._`${fmtRef}.test(${data})`;\n      }\n    }\n  }\n\n};\nexports.default = def;","map":{"version":3,"sources":["D:/happyAngular/node_modules/ajv/dist/vocabularies/format/format.js"],"names":["Object","defineProperty","exports","value","codegen_1","require","error","message","schemaCode","str","params","_","def","keyword","type","schemaType","$data","code","cxt","ruleType","gen","data","schema","it","opts","errSchemaPath","schemaEnv","self","validateFormats","validate$DataFormat","validateFormat","fmts","scopeValue","ref","formats","fDef","const","fType","let","format","if","assign","fail$data","or","unknownFmt","invalidFmt","strictSchema","nil","callFormat","$async","validData","formatDef","unknownFormat","fmtType","fmtRef","getFormat","pass","validCondition","logger","warn","unknownMsg","Error","fmtDef","RegExp","regexpCode","getProperty","undefined","fmt","key","validate","async","default"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst codegen_1 = require(\"../../compile/codegen\");\nconst error = {\n    message: ({ schemaCode }) => codegen_1.str `must match format \"${schemaCode}\"`,\n    params: ({ schemaCode }) => codegen_1._ `{format: ${schemaCode}}`,\n};\nconst def = {\n    keyword: \"format\",\n    type: [\"number\", \"string\"],\n    schemaType: \"string\",\n    $data: true,\n    error,\n    code(cxt, ruleType) {\n        const { gen, data, $data, schema, schemaCode, it } = cxt;\n        const { opts, errSchemaPath, schemaEnv, self } = it;\n        if (!opts.validateFormats)\n            return;\n        if ($data)\n            validate$DataFormat();\n        else\n            validateFormat();\n        function validate$DataFormat() {\n            const fmts = gen.scopeValue(\"formats\", {\n                ref: self.formats,\n                code: opts.code.formats,\n            });\n            const fDef = gen.const(\"fDef\", codegen_1._ `${fmts}[${schemaCode}]`);\n            const fType = gen.let(\"fType\");\n            const format = gen.let(\"format\");\n            // TODO simplify\n            gen.if(codegen_1._ `typeof ${fDef} == \"object\" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, codegen_1._ `${fDef}.type || \"string\"`).assign(format, codegen_1._ `${fDef}.validate`), () => gen.assign(fType, codegen_1._ `\"string\"`).assign(format, fDef));\n            cxt.fail$data(codegen_1.or(unknownFmt(), invalidFmt()));\n            function unknownFmt() {\n                if (opts.strictSchema === false)\n                    return codegen_1.nil;\n                return codegen_1._ `${schemaCode} && !${format}`;\n            }\n            function invalidFmt() {\n                const callFormat = schemaEnv.$async\n                    ? codegen_1._ `(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))`\n                    : codegen_1._ `${format}(${data})`;\n                const validData = codegen_1._ `(typeof ${format} == \"function\" ? ${callFormat} : ${format}.test(${data}))`;\n                return codegen_1._ `${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;\n            }\n        }\n        function validateFormat() {\n            const formatDef = self.formats[schema];\n            if (!formatDef) {\n                unknownFormat();\n                return;\n            }\n            if (formatDef === true)\n                return;\n            const [fmtType, format, fmtRef] = getFormat(formatDef);\n            if (fmtType === ruleType)\n                cxt.pass(validCondition());\n            function unknownFormat() {\n                if (opts.strictSchema === false) {\n                    self.logger.warn(unknownMsg());\n                    return;\n                }\n                throw new Error(unknownMsg());\n                function unknownMsg() {\n                    return `unknown format \"${schema}\" ignored in schema at path \"${errSchemaPath}\"`;\n                }\n            }\n            function getFormat(fmtDef) {\n                const code = fmtDef instanceof RegExp\n                    ? codegen_1.regexpCode(fmtDef)\n                    : opts.code.formats\n                        ? codegen_1._ `${opts.code.formats}${codegen_1.getProperty(schema)}`\n                        : undefined;\n                const fmt = gen.scopeValue(\"formats\", { key: schema, ref: fmtDef, code });\n                if (typeof fmtDef == \"object\" && !(fmtDef instanceof RegExp)) {\n                    return [fmtDef.type || \"string\", fmtDef.validate, codegen_1._ `${fmt}.validate`];\n                }\n                return [\"string\", fmtDef, fmt];\n            }\n            function validCondition() {\n                if (typeof formatDef == \"object\" && !(formatDef instanceof RegExp) && formatDef.async) {\n                    if (!schemaEnv.$async)\n                        throw new Error(\"async format in sync schema\");\n                    return codegen_1._ `await ${fmtRef}(${data})`;\n                }\n                return typeof format == \"function\" ? codegen_1._ `${fmtRef}(${data})` : codegen_1._ `${fmtRef}.test(${data})`;\n            }\n        }\n    },\n};\nexports.default = def;\n"]},"metadata":{},"sourceType":"script"}
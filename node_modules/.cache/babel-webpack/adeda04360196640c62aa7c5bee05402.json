{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\n\nconst codegen_1 = require(\"./codegen\");\n\nconst util_1 = require(\"./util\");\n\nconst names_1 = require(\"./names\");\n\nexports.keywordError = {\n  message: ({\n    keyword\n  }) => codegen_1.str`must pass \"${keyword}\" keyword validation`\n};\nexports.keyword$DataError = {\n  message: ({\n    keyword,\n    schemaType\n  }) => schemaType ? codegen_1.str`\"${keyword}\" keyword must be ${schemaType} ($data)` : codegen_1.str`\"${keyword}\" keyword is invalid ($data)`\n};\n\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n  const {\n    it\n  } = cxt;\n  const {\n    gen,\n    compositeRule,\n    allErrors\n  } = it;\n  const errObj = errorObjectCode(cxt, error, errorPaths);\n\n  if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {\n    addError(gen, errObj);\n  } else {\n    returnErrors(it, codegen_1._`[${errObj}]`);\n  }\n}\n\nexports.reportError = reportError;\n\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n  const {\n    it\n  } = cxt;\n  const {\n    gen,\n    compositeRule,\n    allErrors\n  } = it;\n  const errObj = errorObjectCode(cxt, error, errorPaths);\n  addError(gen, errObj);\n\n  if (!(compositeRule || allErrors)) {\n    returnErrors(it, names_1.default.vErrors);\n  }\n}\n\nexports.reportExtraError = reportExtraError;\n\nfunction resetErrorsCount(gen, errsCount) {\n  gen.assign(names_1.default.errors, errsCount);\n  gen.if(codegen_1._`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_1._`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\n\nexports.resetErrorsCount = resetErrorsCount;\n\nfunction extendErrors({\n  gen,\n  keyword,\n  schemaValue,\n  data,\n  errsCount,\n  it\n}) {\n  /* istanbul ignore if */\n  if (errsCount === undefined) throw new Error(\"ajv implementation error\");\n  const err = gen.name(\"err\");\n  gen.forRange(\"i\", errsCount, names_1.default.errors, i => {\n    gen.const(err, codegen_1._`${names_1.default.vErrors}[${i}]`);\n    gen.if(codegen_1._`${err}.instancePath === undefined`, () => gen.assign(codegen_1._`${err}.instancePath`, codegen_1.strConcat(names_1.default.instancePath, it.errorPath)));\n    gen.assign(codegen_1._`${err}.schemaPath`, codegen_1.str`${it.errSchemaPath}/${keyword}`);\n\n    if (it.opts.verbose) {\n      gen.assign(codegen_1._`${err}.schema`, schemaValue);\n      gen.assign(codegen_1._`${err}.data`, data);\n    }\n  });\n}\n\nexports.extendErrors = extendErrors;\n\nfunction addError(gen, errObj) {\n  const err = gen.const(\"err\", errObj);\n  gen.if(codegen_1._`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, codegen_1._`[${err}]`), codegen_1._`${names_1.default.vErrors}.push(${err})`);\n  gen.code(codegen_1._`${names_1.default.errors}++`);\n}\n\nfunction returnErrors(it, errs) {\n  const {\n    gen,\n    validateName,\n    schemaEnv\n  } = it;\n\n  if (schemaEnv.$async) {\n    gen.throw(codegen_1._`new ${it.ValidationError}(${errs})`);\n  } else {\n    gen.assign(codegen_1._`${validateName}.errors`, errs);\n    gen.return(false);\n  }\n}\n\nconst E = {\n  keyword: new codegen_1.Name(\"keyword\"),\n  schemaPath: new codegen_1.Name(\"schemaPath\"),\n  params: new codegen_1.Name(\"params\"),\n  propertyName: new codegen_1.Name(\"propertyName\"),\n  message: new codegen_1.Name(\"message\"),\n  schema: new codegen_1.Name(\"schema\"),\n  parentSchema: new codegen_1.Name(\"parentSchema\")\n};\n\nfunction errorObjectCode(cxt, error, errorPaths) {\n  const {\n    createErrors\n  } = cxt.it;\n  if (createErrors === false) return codegen_1._`{}`;\n  return errorObject(cxt, error, errorPaths);\n}\n\nfunction errorObject(cxt, error, errorPaths = {}) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const keyValues = [errorInstancePath(it, errorPaths), errorSchemaPath(cxt, errorPaths)];\n  extraErrorProps(cxt, error, keyValues);\n  return gen.object(...keyValues);\n}\n\nfunction errorInstancePath({\n  errorPath\n}, {\n  instancePath\n}) {\n  const instPath = instancePath ? codegen_1.str`${errorPath}${util_1.getErrorPath(instancePath, util_1.Type.Str)}` : errorPath;\n  return [names_1.default.instancePath, codegen_1.strConcat(names_1.default.instancePath, instPath)];\n}\n\nfunction errorSchemaPath({\n  keyword,\n  it: {\n    errSchemaPath\n  }\n}, {\n  schemaPath,\n  parentSchema\n}) {\n  let schPath = parentSchema ? errSchemaPath : codegen_1.str`${errSchemaPath}/${keyword}`;\n\n  if (schemaPath) {\n    schPath = codegen_1.str`${schPath}${util_1.getErrorPath(schemaPath, util_1.Type.Str)}`;\n  }\n\n  return [E.schemaPath, schPath];\n}\n\nfunction extraErrorProps(cxt, {\n  params,\n  message\n}, keyValues) {\n  const {\n    keyword,\n    data,\n    schemaValue,\n    it\n  } = cxt;\n  const {\n    opts,\n    propertyName,\n    topSchemaRef,\n    schemaPath\n  } = it;\n  keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || codegen_1._`{}`]);\n\n  if (opts.messages) {\n    keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n  }\n\n  if (opts.verbose) {\n    keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_1._`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n  }\n\n  if (propertyName) keyValues.push([E.propertyName, propertyName]);\n}","map":{"version":3,"sources":["D:/happyAngular/node_modules/ajv/dist/compile/errors.js"],"names":["Object","defineProperty","exports","value","extendErrors","resetErrorsCount","reportExtraError","reportError","keyword$DataError","keywordError","codegen_1","require","util_1","names_1","message","keyword","str","schemaType","cxt","error","errorPaths","overrideAllErrors","it","gen","compositeRule","allErrors","errObj","errorObjectCode","addError","returnErrors","_","default","vErrors","errsCount","assign","errors","if","schemaValue","data","undefined","Error","err","name","forRange","i","const","strConcat","instancePath","errorPath","errSchemaPath","opts","verbose","code","errs","validateName","schemaEnv","$async","throw","ValidationError","return","E","Name","schemaPath","params","propertyName","schema","parentSchema","createErrors","errorObject","keyValues","errorInstancePath","errorSchemaPath","extraErrorProps","object","instPath","getErrorPath","Type","Str","schPath","topSchemaRef","push","messages"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;\nconst codegen_1 = require(\"./codegen\");\nconst util_1 = require(\"./util\");\nconst names_1 = require(\"./names\");\nexports.keywordError = {\n    message: ({ keyword }) => codegen_1.str `must pass \"${keyword}\" keyword validation`,\n};\nexports.keyword$DataError = {\n    message: ({ keyword, schemaType }) => schemaType\n        ? codegen_1.str `\"${keyword}\" keyword must be ${schemaType} ($data)`\n        : codegen_1.str `\"${keyword}\" keyword is invalid ($data)`,\n};\nfunction reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : (compositeRule || allErrors)) {\n        addError(gen, errObj);\n    }\n    else {\n        returnErrors(it, codegen_1._ `[${errObj}]`);\n    }\n}\nexports.reportError = reportError;\nfunction reportExtraError(cxt, error = exports.keywordError, errorPaths) {\n    const { it } = cxt;\n    const { gen, compositeRule, allErrors } = it;\n    const errObj = errorObjectCode(cxt, error, errorPaths);\n    addError(gen, errObj);\n    if (!(compositeRule || allErrors)) {\n        returnErrors(it, names_1.default.vErrors);\n    }\n}\nexports.reportExtraError = reportExtraError;\nfunction resetErrorsCount(gen, errsCount) {\n    gen.assign(names_1.default.errors, errsCount);\n    gen.if(codegen_1._ `${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign(codegen_1._ `${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));\n}\nexports.resetErrorsCount = resetErrorsCount;\nfunction extendErrors({ gen, keyword, schemaValue, data, errsCount, it, }) {\n    /* istanbul ignore if */\n    if (errsCount === undefined)\n        throw new Error(\"ajv implementation error\");\n    const err = gen.name(\"err\");\n    gen.forRange(\"i\", errsCount, names_1.default.errors, (i) => {\n        gen.const(err, codegen_1._ `${names_1.default.vErrors}[${i}]`);\n        gen.if(codegen_1._ `${err}.instancePath === undefined`, () => gen.assign(codegen_1._ `${err}.instancePath`, codegen_1.strConcat(names_1.default.instancePath, it.errorPath)));\n        gen.assign(codegen_1._ `${err}.schemaPath`, codegen_1.str `${it.errSchemaPath}/${keyword}`);\n        if (it.opts.verbose) {\n            gen.assign(codegen_1._ `${err}.schema`, schemaValue);\n            gen.assign(codegen_1._ `${err}.data`, data);\n        }\n    });\n}\nexports.extendErrors = extendErrors;\nfunction addError(gen, errObj) {\n    const err = gen.const(\"err\", errObj);\n    gen.if(codegen_1._ `${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, codegen_1._ `[${err}]`), codegen_1._ `${names_1.default.vErrors}.push(${err})`);\n    gen.code(codegen_1._ `${names_1.default.errors}++`);\n}\nfunction returnErrors(it, errs) {\n    const { gen, validateName, schemaEnv } = it;\n    if (schemaEnv.$async) {\n        gen.throw(codegen_1._ `new ${it.ValidationError}(${errs})`);\n    }\n    else {\n        gen.assign(codegen_1._ `${validateName}.errors`, errs);\n        gen.return(false);\n    }\n}\nconst E = {\n    keyword: new codegen_1.Name(\"keyword\"),\n    schemaPath: new codegen_1.Name(\"schemaPath\"),\n    params: new codegen_1.Name(\"params\"),\n    propertyName: new codegen_1.Name(\"propertyName\"),\n    message: new codegen_1.Name(\"message\"),\n    schema: new codegen_1.Name(\"schema\"),\n    parentSchema: new codegen_1.Name(\"parentSchema\"),\n};\nfunction errorObjectCode(cxt, error, errorPaths) {\n    const { createErrors } = cxt.it;\n    if (createErrors === false)\n        return codegen_1._ `{}`;\n    return errorObject(cxt, error, errorPaths);\n}\nfunction errorObject(cxt, error, errorPaths = {}) {\n    const { gen, it } = cxt;\n    const keyValues = [\n        errorInstancePath(it, errorPaths),\n        errorSchemaPath(cxt, errorPaths),\n    ];\n    extraErrorProps(cxt, error, keyValues);\n    return gen.object(...keyValues);\n}\nfunction errorInstancePath({ errorPath }, { instancePath }) {\n    const instPath = instancePath\n        ? codegen_1.str `${errorPath}${util_1.getErrorPath(instancePath, util_1.Type.Str)}`\n        : errorPath;\n    return [names_1.default.instancePath, codegen_1.strConcat(names_1.default.instancePath, instPath)];\n}\nfunction errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {\n    let schPath = parentSchema ? errSchemaPath : codegen_1.str `${errSchemaPath}/${keyword}`;\n    if (schemaPath) {\n        schPath = codegen_1.str `${schPath}${util_1.getErrorPath(schemaPath, util_1.Type.Str)}`;\n    }\n    return [E.schemaPath, schPath];\n}\nfunction extraErrorProps(cxt, { params, message }, keyValues) {\n    const { keyword, data, schemaValue, it } = cxt;\n    const { opts, propertyName, topSchemaRef, schemaPath } = it;\n    keyValues.push([E.keyword, keyword], [E.params, typeof params == \"function\" ? params(cxt) : params || codegen_1._ `{}`]);\n    if (opts.messages) {\n        keyValues.push([E.message, typeof message == \"function\" ? message(cxt) : message]);\n    }\n    if (opts.verbose) {\n        keyValues.push([E.schema, schemaValue], [E.parentSchema, codegen_1._ `${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);\n    }\n    if (propertyName)\n        keyValues.push([E.propertyName, propertyName]);\n}\n"]},"metadata":{},"sourceType":"script"}
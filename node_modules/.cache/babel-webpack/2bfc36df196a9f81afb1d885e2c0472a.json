{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\n\nconst errors_1 = require(\"../errors\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst boolError = {\n  message: \"boolean schema is false\"\n};\n\nfunction topBoolOrEmptySchema(it) {\n  const {\n    gen,\n    schema,\n    validateName\n  } = it;\n\n  if (schema === false) {\n    falseSchemaError(it, false);\n  } else if (typeof schema == \"object\" && schema.$async === true) {\n    gen.return(names_1.default.data);\n  } else {\n    gen.assign(codegen_1._`${validateName}.errors`, null);\n    gen.return(true);\n  }\n}\n\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\n\nfunction boolOrEmptySchema(it, valid) {\n  const {\n    gen,\n    schema\n  } = it;\n\n  if (schema === false) {\n    gen.var(valid, false); // TODO var\n\n    falseSchemaError(it);\n  } else {\n    gen.var(valid, true); // TODO var\n  }\n}\n\nexports.boolOrEmptySchema = boolOrEmptySchema;\n\nfunction falseSchemaError(it, overrideAllErrors) {\n  const {\n    gen,\n    data\n  } = it; // TODO maybe some other interface should be used for non-keyword validation errors...\n\n  const cxt = {\n    gen,\n    keyword: \"false schema\",\n    data,\n    schema: false,\n    schemaCode: false,\n    schemaValue: false,\n    params: {},\n    it\n  };\n  errors_1.reportError(cxt, boolError, undefined, overrideAllErrors);\n}","map":{"version":3,"sources":["D:/happyAngular/node_modules/ajv/dist/compile/validate/boolSchema.js"],"names":["Object","defineProperty","exports","value","boolOrEmptySchema","topBoolOrEmptySchema","errors_1","require","codegen_1","names_1","boolError","message","it","gen","schema","validateName","falseSchemaError","$async","return","default","data","assign","_","valid","var","overrideAllErrors","cxt","keyword","schemaCode","schemaValue","params","reportError","undefined"],"mappings":"AAAA;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;AACAD,OAAO,CAACE,iBAAR,GAA4BF,OAAO,CAACG,oBAAR,GAA+B,KAAK,CAAhE;;AACA,MAAMC,QAAQ,GAAGC,OAAO,CAAC,WAAD,CAAxB;;AACA,MAAMC,SAAS,GAAGD,OAAO,CAAC,YAAD,CAAzB;;AACA,MAAME,OAAO,GAAGF,OAAO,CAAC,UAAD,CAAvB;;AACA,MAAMG,SAAS,GAAG;AACdC,EAAAA,OAAO,EAAE;AADK,CAAlB;;AAGA,SAASN,oBAAT,CAA8BO,EAA9B,EAAkC;AAC9B,QAAM;AAAEC,IAAAA,GAAF;AAAOC,IAAAA,MAAP;AAAeC,IAAAA;AAAf,MAAgCH,EAAtC;;AACA,MAAIE,MAAM,KAAK,KAAf,EAAsB;AAClBE,IAAAA,gBAAgB,CAACJ,EAAD,EAAK,KAAL,CAAhB;AACH,GAFD,MAGK,IAAI,OAAOE,MAAP,IAAiB,QAAjB,IAA6BA,MAAM,CAACG,MAAP,KAAkB,IAAnD,EAAyD;AAC1DJ,IAAAA,GAAG,CAACK,MAAJ,CAAWT,OAAO,CAACU,OAAR,CAAgBC,IAA3B;AACH,GAFI,MAGA;AACDP,IAAAA,GAAG,CAACQ,MAAJ,CAAWb,SAAS,CAACc,CAAG,GAAEP,YAAa,SAAvC,EAAiD,IAAjD;AACAF,IAAAA,GAAG,CAACK,MAAJ,CAAW,IAAX;AACH;AACJ;;AACDhB,OAAO,CAACG,oBAAR,GAA+BA,oBAA/B;;AACA,SAASD,iBAAT,CAA2BQ,EAA3B,EAA+BW,KAA/B,EAAsC;AAClC,QAAM;AAAEV,IAAAA,GAAF;AAAOC,IAAAA;AAAP,MAAkBF,EAAxB;;AACA,MAAIE,MAAM,KAAK,KAAf,EAAsB;AAClBD,IAAAA,GAAG,CAACW,GAAJ,CAAQD,KAAR,EAAe,KAAf,EADkB,CACK;;AACvBP,IAAAA,gBAAgB,CAACJ,EAAD,CAAhB;AACH,GAHD,MAIK;AACDC,IAAAA,GAAG,CAACW,GAAJ,CAAQD,KAAR,EAAe,IAAf,EADC,CACqB;AACzB;AACJ;;AACDrB,OAAO,CAACE,iBAAR,GAA4BA,iBAA5B;;AACA,SAASY,gBAAT,CAA0BJ,EAA1B,EAA8Ba,iBAA9B,EAAiD;AAC7C,QAAM;AAAEZ,IAAAA,GAAF;AAAOO,IAAAA;AAAP,MAAgBR,EAAtB,CAD6C,CAE7C;;AACA,QAAMc,GAAG,GAAG;AACRb,IAAAA,GADQ;AAERc,IAAAA,OAAO,EAAE,cAFD;AAGRP,IAAAA,IAHQ;AAIRN,IAAAA,MAAM,EAAE,KAJA;AAKRc,IAAAA,UAAU,EAAE,KALJ;AAMRC,IAAAA,WAAW,EAAE,KANL;AAORC,IAAAA,MAAM,EAAE,EAPA;AAQRlB,IAAAA;AARQ,GAAZ;AAUAN,EAAAA,QAAQ,CAACyB,WAAT,CAAqBL,GAArB,EAA0BhB,SAA1B,EAAqCsB,SAArC,EAAgDP,iBAAhD;AACH","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;\nconst errors_1 = require(\"../errors\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst boolError = {\n    message: \"boolean schema is false\",\n};\nfunction topBoolOrEmptySchema(it) {\n    const { gen, schema, validateName } = it;\n    if (schema === false) {\n        falseSchemaError(it, false);\n    }\n    else if (typeof schema == \"object\" && schema.$async === true) {\n        gen.return(names_1.default.data);\n    }\n    else {\n        gen.assign(codegen_1._ `${validateName}.errors`, null);\n        gen.return(true);\n    }\n}\nexports.topBoolOrEmptySchema = topBoolOrEmptySchema;\nfunction boolOrEmptySchema(it, valid) {\n    const { gen, schema } = it;\n    if (schema === false) {\n        gen.var(valid, false); // TODO var\n        falseSchemaError(it);\n    }\n    else {\n        gen.var(valid, true); // TODO var\n    }\n}\nexports.boolOrEmptySchema = boolOrEmptySchema;\nfunction falseSchemaError(it, overrideAllErrors) {\n    const { gen, data } = it;\n    // TODO maybe some other interface should be used for non-keyword validation errors...\n    const cxt = {\n        gen,\n        keyword: \"false schema\",\n        data,\n        schema: false,\n        schemaCode: false,\n        schemaValue: false,\n        params: {},\n        it,\n    };\n    errors_1.reportError(cxt, boolError, undefined, overrideAllErrors);\n}\n"]},"metadata":{},"sourceType":"script"}
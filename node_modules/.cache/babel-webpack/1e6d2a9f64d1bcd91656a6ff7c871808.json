{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.callRef = exports.getValidate = void 0;\n\nconst ref_error_1 = require(\"../../compile/ref_error\");\n\nconst code_1 = require(\"../code\");\n\nconst codegen_1 = require(\"../../compile/codegen\");\n\nconst names_1 = require(\"../../compile/names\");\n\nconst compile_1 = require(\"../../compile\");\n\nconst util_1 = require(\"../../compile/util\");\n\nconst def = {\n  keyword: \"$ref\",\n  schemaType: \"string\",\n\n  code(cxt) {\n    const {\n      gen,\n      schema: $ref,\n      it\n    } = cxt;\n    const {\n      baseId,\n      schemaEnv: env,\n      validateName,\n      opts,\n      self\n    } = it;\n    const {\n      root\n    } = env;\n    if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId) return callRootRef();\n    const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n    if (schOrEnv === undefined) throw new ref_error_1.default(baseId, $ref);\n    if (schOrEnv instanceof compile_1.SchemaEnv) return callValidate(schOrEnv);\n    return inlineRefSchema(schOrEnv);\n\n    function callRootRef() {\n      if (env === root) return callRef(cxt, validateName, env, env.$async);\n      const rootName = gen.scopeValue(\"root\", {\n        ref: root\n      });\n      return callRef(cxt, codegen_1._`${rootName}.validate`, root, root.$async);\n    }\n\n    function callValidate(sch) {\n      const v = getValidate(cxt, sch);\n      callRef(cxt, v, sch, sch.$async);\n    }\n\n    function inlineRefSchema(sch) {\n      const schName = gen.scopeValue(\"schema\", opts.code.source === true ? {\n        ref: sch,\n        code: codegen_1.stringify(sch)\n      } : {\n        ref: sch\n      });\n      const valid = gen.name(\"valid\");\n      const schCxt = cxt.subschema({\n        schema: sch,\n        dataTypes: [],\n        schemaPath: codegen_1.nil,\n        topSchemaRef: schName,\n        errSchemaPath: $ref\n      }, valid);\n      cxt.mergeEvaluated(schCxt);\n      cxt.ok(valid);\n    }\n  }\n\n};\n\nfunction getValidate(cxt, sch) {\n  const {\n    gen\n  } = cxt;\n  return sch.validate ? gen.scopeValue(\"validate\", {\n    ref: sch.validate\n  }) : codegen_1._`${gen.scopeValue(\"wrapper\", {\n    ref: sch\n  })}.validate`;\n}\n\nexports.getValidate = getValidate;\n\nfunction callRef(cxt, v, sch, $async) {\n  const {\n    gen,\n    it\n  } = cxt;\n  const {\n    allErrors,\n    schemaEnv: env,\n    opts\n  } = it;\n  const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n  if ($async) callAsyncRef();else callSyncRef();\n\n  function callAsyncRef() {\n    if (!env.$async) throw new Error(\"async schema referenced by sync schema\");\n    const valid = gen.let(\"valid\");\n    gen.try(() => {\n      gen.code(codegen_1._`await ${code_1.callValidateCode(cxt, v, passCxt)}`);\n      addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n\n      if (!allErrors) gen.assign(valid, true);\n    }, e => {\n      gen.if(codegen_1._`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n      addErrorsFrom(e);\n      if (!allErrors) gen.assign(valid, false);\n    });\n    cxt.ok(valid);\n  }\n\n  function callSyncRef() {\n    cxt.result(code_1.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n  }\n\n  function addErrorsFrom(source) {\n    const errs = codegen_1._`${source}.errors`;\n    gen.assign(names_1.default.vErrors, codegen_1._`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n\n    gen.assign(names_1.default.errors, codegen_1._`${names_1.default.vErrors}.length`);\n  }\n\n  function addEvaluatedFrom(source) {\n    var _a;\n\n    if (!it.opts.unevaluated) return;\n    const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated; // TODO refactor\n\n    if (it.props !== true) {\n      if (schEvaluated && !schEvaluated.dynamicProps) {\n        if (schEvaluated.props !== undefined) {\n          it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n        }\n      } else {\n        const props = gen.var(\"props\", codegen_1._`${source}.evaluated.props`);\n        it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n      }\n    }\n\n    if (it.items !== true) {\n      if (schEvaluated && !schEvaluated.dynamicItems) {\n        if (schEvaluated.items !== undefined) {\n          it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n        }\n      } else {\n        const items = gen.var(\"items\", codegen_1._`${source}.evaluated.items`);\n        it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n      }\n    }\n  }\n}\n\nexports.callRef = callRef;\nexports.default = def;","map":{"version":3,"sources":["D:/happyAngular/node_modules/ajv/dist/vocabularies/core/ref.js"],"names":["Object","defineProperty","exports","value","callRef","getValidate","ref_error_1","require","code_1","codegen_1","names_1","compile_1","util_1","def","keyword","schemaType","code","cxt","gen","schema","$ref","it","baseId","schemaEnv","env","validateName","opts","self","root","callRootRef","schOrEnv","resolveRef","call","undefined","default","SchemaEnv","callValidate","inlineRefSchema","$async","rootName","scopeValue","ref","_","sch","v","schName","source","stringify","valid","name","schCxt","subschema","dataTypes","schemaPath","nil","topSchemaRef","errSchemaPath","mergeEvaluated","ok","validate","allErrors","passCxt","passContext","this","callAsyncRef","callSyncRef","Error","let","try","callValidateCode","addEvaluatedFrom","assign","e","if","ValidationError","throw","addErrorsFrom","result","errs","vErrors","errors","_a","unevaluated","schEvaluated","evaluated","props","dynamicProps","var","Name","items","dynamicItems"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.callRef = exports.getValidate = void 0;\nconst ref_error_1 = require(\"../../compile/ref_error\");\nconst code_1 = require(\"../code\");\nconst codegen_1 = require(\"../../compile/codegen\");\nconst names_1 = require(\"../../compile/names\");\nconst compile_1 = require(\"../../compile\");\nconst util_1 = require(\"../../compile/util\");\nconst def = {\n    keyword: \"$ref\",\n    schemaType: \"string\",\n    code(cxt) {\n        const { gen, schema: $ref, it } = cxt;\n        const { baseId, schemaEnv: env, validateName, opts, self } = it;\n        const { root } = env;\n        if (($ref === \"#\" || $ref === \"#/\") && baseId === root.baseId)\n            return callRootRef();\n        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);\n        if (schOrEnv === undefined)\n            throw new ref_error_1.default(baseId, $ref);\n        if (schOrEnv instanceof compile_1.SchemaEnv)\n            return callValidate(schOrEnv);\n        return inlineRefSchema(schOrEnv);\n        function callRootRef() {\n            if (env === root)\n                return callRef(cxt, validateName, env, env.$async);\n            const rootName = gen.scopeValue(\"root\", { ref: root });\n            return callRef(cxt, codegen_1._ `${rootName}.validate`, root, root.$async);\n        }\n        function callValidate(sch) {\n            const v = getValidate(cxt, sch);\n            callRef(cxt, v, sch, sch.$async);\n        }\n        function inlineRefSchema(sch) {\n            const schName = gen.scopeValue(\"schema\", opts.code.source === true ? { ref: sch, code: codegen_1.stringify(sch) } : { ref: sch });\n            const valid = gen.name(\"valid\");\n            const schCxt = cxt.subschema({\n                schema: sch,\n                dataTypes: [],\n                schemaPath: codegen_1.nil,\n                topSchemaRef: schName,\n                errSchemaPath: $ref,\n            }, valid);\n            cxt.mergeEvaluated(schCxt);\n            cxt.ok(valid);\n        }\n    },\n};\nfunction getValidate(cxt, sch) {\n    const { gen } = cxt;\n    return sch.validate\n        ? gen.scopeValue(\"validate\", { ref: sch.validate })\n        : codegen_1._ `${gen.scopeValue(\"wrapper\", { ref: sch })}.validate`;\n}\nexports.getValidate = getValidate;\nfunction callRef(cxt, v, sch, $async) {\n    const { gen, it } = cxt;\n    const { allErrors, schemaEnv: env, opts } = it;\n    const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;\n    if ($async)\n        callAsyncRef();\n    else\n        callSyncRef();\n    function callAsyncRef() {\n        if (!env.$async)\n            throw new Error(\"async schema referenced by sync schema\");\n        const valid = gen.let(\"valid\");\n        gen.try(() => {\n            gen.code(codegen_1._ `await ${code_1.callValidateCode(cxt, v, passCxt)}`);\n            addEvaluatedFrom(v); // TODO will not work with async, it has to be returned with the result\n            if (!allErrors)\n                gen.assign(valid, true);\n        }, (e) => {\n            gen.if(codegen_1._ `!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));\n            addErrorsFrom(e);\n            if (!allErrors)\n                gen.assign(valid, false);\n        });\n        cxt.ok(valid);\n    }\n    function callSyncRef() {\n        cxt.result(code_1.callValidateCode(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));\n    }\n    function addErrorsFrom(source) {\n        const errs = codegen_1._ `${source}.errors`;\n        gen.assign(names_1.default.vErrors, codegen_1._ `${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`); // TODO tagged\n        gen.assign(names_1.default.errors, codegen_1._ `${names_1.default.vErrors}.length`);\n    }\n    function addEvaluatedFrom(source) {\n        var _a;\n        if (!it.opts.unevaluated)\n            return;\n        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;\n        // TODO refactor\n        if (it.props !== true) {\n            if (schEvaluated && !schEvaluated.dynamicProps) {\n                if (schEvaluated.props !== undefined) {\n                    it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);\n                }\n            }\n            else {\n                const props = gen.var(\"props\", codegen_1._ `${source}.evaluated.props`);\n                it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);\n            }\n        }\n        if (it.items !== true) {\n            if (schEvaluated && !schEvaluated.dynamicItems) {\n                if (schEvaluated.items !== undefined) {\n                    it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);\n                }\n            }\n            else {\n                const items = gen.var(\"items\", codegen_1._ `${source}.evaluated.items`);\n                it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);\n            }\n        }\n    }\n}\nexports.callRef = callRef;\nexports.default = def;\n"]},"metadata":{},"sourceType":"script"}
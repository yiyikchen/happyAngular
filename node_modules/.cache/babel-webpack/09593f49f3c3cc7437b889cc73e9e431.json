{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\n\nconst boolSchema_1 = require(\"./boolSchema\");\n\nconst dataType_1 = require(\"./dataType\");\n\nconst applicability_1 = require(\"./applicability\");\n\nconst dataType_2 = require(\"./dataType\");\n\nconst defaults_1 = require(\"./defaults\");\n\nconst keyword_1 = require(\"./keyword\");\n\nconst subschema_1 = require(\"./subschema\");\n\nconst codegen_1 = require(\"../codegen\");\n\nconst names_1 = require(\"../names\");\n\nconst resolve_1 = require(\"../resolve\");\n\nconst util_1 = require(\"../util\");\n\nconst errors_1 = require(\"../errors\"); // schema compilation - generates validation function, subschemaCode (below) is used for subschemas\n\n\nfunction validateFunctionCode(it) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      topSchemaObjCode(it);\n      return;\n    }\n  }\n\n  validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));\n}\n\nexports.validateFunctionCode = validateFunctionCode;\n\nfunction validateFunction({\n  gen,\n  validateName,\n  schema,\n  schemaEnv,\n  opts\n}, body) {\n  if (opts.code.es5) {\n    gen.func(validateName, codegen_1._`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n      gen.code(codegen_1._`\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n      destructureValCxtES5(gen, opts);\n      gen.code(body);\n    });\n  } else {\n    gen.func(validateName, codegen_1._`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n  }\n}\n\nfunction destructureValCxt(opts) {\n  return codegen_1._`{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\n\nfunction destructureValCxtES5(gen, opts) {\n  gen.if(names_1.default.valCxt, () => {\n    gen.var(names_1.default.instancePath, codegen_1._`${names_1.default.valCxt}.${names_1.default.instancePath}`);\n    gen.var(names_1.default.parentData, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentData}`);\n    gen.var(names_1.default.parentDataProperty, codegen_1._`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n    gen.var(names_1.default.rootData, codegen_1._`${names_1.default.valCxt}.${names_1.default.rootData}`);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n  }, () => {\n    gen.var(names_1.default.instancePath, codegen_1._`\"\"`);\n    gen.var(names_1.default.parentData, codegen_1._`undefined`);\n    gen.var(names_1.default.parentDataProperty, codegen_1._`undefined`);\n    gen.var(names_1.default.rootData, names_1.default.data);\n    if (opts.dynamicRef) gen.var(names_1.default.dynamicAnchors, codegen_1._`{}`);\n  });\n}\n\nfunction topSchemaObjCode(it) {\n  const {\n    schema,\n    opts,\n    gen\n  } = it;\n  validateFunction(it, () => {\n    if (opts.$comment && schema.$comment) commentKeyword(it);\n    checkNoDefault(it);\n    gen.let(names_1.default.vErrors, null);\n    gen.let(names_1.default.errors, 0);\n    if (opts.unevaluated) resetEvaluated(it);\n    typeAndKeywords(it);\n    returnResults(it);\n  });\n  return;\n}\n\nfunction resetEvaluated(it) {\n  // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n  const {\n    gen,\n    validateName\n  } = it;\n  it.evaluated = gen.const(\"evaluated\", codegen_1._`${validateName}.evaluated`);\n  gen.if(codegen_1._`${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._`${it.evaluated}.props`, codegen_1._`undefined`));\n  gen.if(codegen_1._`${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._`${it.evaluated}.items`, codegen_1._`undefined`));\n}\n\nfunction funcSourceUrl(schema, opts) {\n  const schId = typeof schema == \"object\" && schema[opts.schemaId];\n  return schId && (opts.code.source || opts.code.process) ? codegen_1._`/*# sourceURL=${schId} */` : codegen_1.nil;\n} // schema compilation - this function is used recursively to generate code for sub-schemas\n\n\nfunction subschemaCode(it, valid) {\n  if (isSchemaObj(it)) {\n    checkKeywords(it);\n\n    if (schemaCxtHasRules(it)) {\n      subSchemaObjCode(it, valid);\n      return;\n    }\n  }\n\n  boolSchema_1.boolOrEmptySchema(it, valid);\n}\n\nfunction schemaCxtHasRules({\n  schema,\n  self\n}) {\n  if (typeof schema == \"boolean\") return !schema;\n\n  for (const key in schema) if (self.RULES.all[key]) return true;\n\n  return false;\n}\n\nfunction isSchemaObj(it) {\n  return typeof it.schema != \"boolean\";\n}\n\nfunction subSchemaObjCode(it, valid) {\n  const {\n    schema,\n    gen,\n    opts\n  } = it;\n  if (opts.$comment && schema.$comment) commentKeyword(it);\n  updateContext(it);\n  checkAsyncSchema(it);\n  const errsCount = gen.const(\"_errs\", names_1.default.errors);\n  typeAndKeywords(it, errsCount); // TODO var\n\n  gen.var(valid, codegen_1._`${errsCount} === ${names_1.default.errors}`);\n}\n\nfunction checkKeywords(it) {\n  util_1.checkUnknownRules(it);\n  checkRefsAndKeywords(it);\n}\n\nfunction typeAndKeywords(it, errsCount) {\n  if (it.opts.jtd) return schemaKeywords(it, [], false, errsCount);\n  const types = dataType_1.getSchemaTypes(it.schema);\n  const checkedTypes = dataType_1.coerceAndCheckDataType(it, types);\n  schemaKeywords(it, types, !checkedTypes, errsCount);\n}\n\nfunction checkRefsAndKeywords(it) {\n  const {\n    schema,\n    errSchemaPath,\n    opts,\n    self\n  } = it;\n\n  if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {\n    self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n  }\n}\n\nfunction checkNoDefault(it) {\n  const {\n    schema,\n    opts\n  } = it;\n\n  if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n    util_1.checkStrictMode(it, \"default is ignored in the schema root\");\n  }\n}\n\nfunction updateContext(it) {\n  const schId = it.schema[it.opts.schemaId];\n  if (schId) it.baseId = resolve_1.resolveUrl(it.baseId, schId);\n}\n\nfunction checkAsyncSchema(it) {\n  if (it.schema.$async && !it.schemaEnv.$async) throw new Error(\"async schema in sync schema\");\n}\n\nfunction commentKeyword({\n  gen,\n  schemaEnv,\n  schema,\n  errSchemaPath,\n  opts\n}) {\n  const msg = schema.$comment;\n\n  if (opts.$comment === true) {\n    gen.code(codegen_1._`${names_1.default.self}.logger.log(${msg})`);\n  } else if (typeof opts.$comment == \"function\") {\n    const schemaPath = codegen_1.str`${errSchemaPath}/$comment`;\n    const rootName = gen.scopeValue(\"root\", {\n      ref: schemaEnv.root\n    });\n    gen.code(codegen_1._`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n  }\n}\n\nfunction returnResults(it) {\n  const {\n    gen,\n    schemaEnv,\n    validateName,\n    ValidationError,\n    opts\n  } = it;\n\n  if (schemaEnv.$async) {\n    // TODO assign unevaluated\n    gen.if(codegen_1._`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._`new ${ValidationError}(${names_1.default.vErrors})`));\n  } else {\n    gen.assign(codegen_1._`${validateName}.errors`, names_1.default.vErrors);\n    if (opts.unevaluated) assignEvaluated(it);\n    gen.return(codegen_1._`${names_1.default.errors} === 0`);\n  }\n}\n\nfunction assignEvaluated({\n  gen,\n  evaluated,\n  props,\n  items\n}) {\n  if (props instanceof codegen_1.Name) gen.assign(codegen_1._`${evaluated}.props`, props);\n  if (items instanceof codegen_1.Name) gen.assign(codegen_1._`${evaluated}.items`, items);\n}\n\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n  const {\n    gen,\n    schema,\n    data,\n    allErrors,\n    opts,\n    self\n  } = it;\n  const {\n    RULES\n  } = self;\n\n  if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {\n    gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n\n    return;\n  }\n\n  if (!opts.jtd) checkStrictTypes(it, types);\n  gen.block(() => {\n    for (const group of RULES.rules) groupKeywords(group);\n\n    groupKeywords(RULES.post);\n  });\n\n  function groupKeywords(group) {\n    if (!applicability_1.shouldUseGroup(schema, group)) return;\n\n    if (group.type) {\n      gen.if(dataType_2.checkDataType(group.type, data, opts.strictNumbers));\n      iterateKeywords(it, group);\n\n      if (types.length === 1 && types[0] === group.type && typeErrors) {\n        gen.else();\n        dataType_2.reportTypeError(it);\n      }\n\n      gen.endIf();\n    } else {\n      iterateKeywords(it, group);\n    } // TODO make it \"ok\" call?\n\n\n    if (!allErrors) gen.if(codegen_1._`${names_1.default.errors} === ${errsCount || 0}`);\n  }\n}\n\nfunction iterateKeywords(it, group) {\n  const {\n    gen,\n    schema,\n    opts: {\n      useDefaults\n    }\n  } = it;\n  if (useDefaults) defaults_1.assignDefaults(it, group.type);\n  gen.block(() => {\n    for (const rule of group.rules) {\n      if (applicability_1.shouldUseRule(schema, rule)) {\n        keywordCode(it, rule.keyword, rule.definition, group.type);\n      }\n    }\n  });\n}\n\nfunction checkStrictTypes(it, types) {\n  if (it.schemaEnv.meta || !it.opts.strictTypes) return;\n  checkContextTypes(it, types);\n  if (!it.opts.allowUnionTypes) checkMultipleTypes(it, types);\n  checkKeywordTypes(it, it.dataTypes);\n}\n\nfunction checkContextTypes(it, types) {\n  if (!types.length) return;\n\n  if (!it.dataTypes.length) {\n    it.dataTypes = types;\n    return;\n  }\n\n  types.forEach(t => {\n    if (!includesType(it.dataTypes, t)) {\n      strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n    }\n  });\n  it.dataTypes = it.dataTypes.filter(t => includesType(types, t));\n}\n\nfunction checkMultipleTypes(it, ts) {\n  if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n    strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n  }\n}\n\nfunction checkKeywordTypes(it, ts) {\n  const rules = it.self.RULES.all;\n\n  for (const keyword in rules) {\n    const rule = rules[keyword];\n\n    if (typeof rule == \"object\" && applicability_1.shouldUseRule(it.schema, rule)) {\n      const {\n        type\n      } = rule.definition;\n\n      if (type.length && !type.some(t => hasApplicableType(ts, t))) {\n        strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n      }\n    }\n  }\n}\n\nfunction hasApplicableType(schTs, kwdT) {\n  return schTs.includes(kwdT) || kwdT === \"number\" && schTs.includes(\"integer\");\n}\n\nfunction includesType(ts, t) {\n  return ts.includes(t) || t === \"integer\" && ts.includes(\"number\");\n}\n\nfunction strictTypesError(it, msg) {\n  const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n  msg += ` at \"${schemaPath}\" (strictTypes)`;\n  util_1.checkStrictMode(it, msg, it.opts.strictTypes);\n}\n\nclass KeywordCxt {\n  constructor(it, def, keyword) {\n    keyword_1.validateKeywordUsage(it, def, keyword);\n    this.gen = it.gen;\n    this.allErrors = it.allErrors;\n    this.keyword = keyword;\n    this.data = it.data;\n    this.schema = it.schema[keyword];\n    this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n    this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);\n    this.schemaType = def.schemaType;\n    this.parentSchema = it.schema;\n    this.params = {};\n    this.it = it;\n    this.def = def;\n\n    if (this.$data) {\n      this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n    } else {\n      this.schemaCode = this.schemaValue;\n\n      if (!keyword_1.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n        throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n      }\n    }\n\n    if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n      this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n    }\n  }\n\n  result(condition, successAction, failAction) {\n    this.failResult(codegen_1.not(condition), successAction, failAction);\n  }\n\n  failResult(condition, successAction, failAction) {\n    this.gen.if(condition);\n    if (failAction) failAction();else this.error();\n\n    if (successAction) {\n      this.gen.else();\n      successAction();\n      if (this.allErrors) this.gen.endIf();\n    } else {\n      if (this.allErrors) this.gen.endIf();else this.gen.else();\n    }\n  }\n\n  pass(condition, failAction) {\n    this.failResult(codegen_1.not(condition), undefined, failAction);\n  }\n\n  fail(condition) {\n    if (condition === undefined) {\n      this.error();\n      if (!this.allErrors) this.gen.if(false); // this branch will be removed by gen.optimize\n\n      return;\n    }\n\n    this.gen.if(condition);\n    this.error();\n    if (this.allErrors) this.gen.endIf();else this.gen.else();\n  }\n\n  fail$data(condition) {\n    if (!this.$data) return this.fail(condition);\n    const {\n      schemaCode\n    } = this;\n    this.fail(codegen_1._`${schemaCode} !== undefined && (${codegen_1.or(this.invalid$data(), condition)})`);\n  }\n\n  error(append, errorParams, errorPaths) {\n    if (errorParams) {\n      this.setParams(errorParams);\n\n      this._error(append, errorPaths);\n\n      this.setParams({});\n      return;\n    }\n\n    this._error(append, errorPaths);\n  }\n\n  _error(append, errorPaths) {\n    ;\n    (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n  }\n\n  $dataError() {\n    errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);\n  }\n\n  reset() {\n    if (this.errsCount === undefined) throw new Error('add \"trackErrors\" to keyword definition');\n    errors_1.resetErrorsCount(this.gen, this.errsCount);\n  }\n\n  ok(cond) {\n    if (!this.allErrors) this.gen.if(cond);\n  }\n\n  setParams(obj, assign) {\n    if (assign) Object.assign(this.params, obj);else this.params = obj;\n  }\n\n  block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n    this.gen.block(() => {\n      this.check$data(valid, $dataValid);\n      codeBlock();\n    });\n  }\n\n  check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n    if (!this.$data) return;\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def\n    } = this;\n    gen.if(codegen_1.or(codegen_1._`${schemaCode} === undefined`, $dataValid));\n    if (valid !== codegen_1.nil) gen.assign(valid, true);\n\n    if (schemaType.length || def.validateSchema) {\n      gen.elseIf(this.invalid$data());\n      this.$dataError();\n      if (valid !== codegen_1.nil) gen.assign(valid, false);\n    }\n\n    gen.else();\n  }\n\n  invalid$data() {\n    const {\n      gen,\n      schemaCode,\n      schemaType,\n      def,\n      it\n    } = this;\n    return codegen_1.or(wrong$DataType(), invalid$DataSchema());\n\n    function wrong$DataType() {\n      if (schemaType.length) {\n        /* istanbul ignore if */\n        if (!(schemaCode instanceof codegen_1.Name)) throw new Error(\"ajv implementation error\");\n        const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n        return codegen_1._`${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n      }\n\n      return codegen_1.nil;\n    }\n\n    function invalid$DataSchema() {\n      if (def.validateSchema) {\n        const validateSchemaRef = gen.scopeValue(\"validate$data\", {\n          ref: def.validateSchema\n        }); // TODO value.code for standalone\n\n        return codegen_1._`!${validateSchemaRef}(${schemaCode})`;\n      }\n\n      return codegen_1.nil;\n    }\n  }\n\n  subschema(appl, valid) {\n    const subschema = subschema_1.getSubschema(this.it, appl);\n    subschema_1.extendSubschemaData(subschema, this.it, appl);\n    subschema_1.extendSubschemaMode(subschema, appl);\n    const nextContext = { ...this.it,\n      ...subschema,\n      items: undefined,\n      props: undefined\n    };\n    subschemaCode(nextContext, valid);\n    return nextContext;\n  }\n\n  mergeEvaluated(schemaCxt, toName) {\n    const {\n      it,\n      gen\n    } = this;\n    if (!it.opts.unevaluated) return;\n\n    if (it.props !== true && schemaCxt.props !== undefined) {\n      it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n    }\n\n    if (it.items !== true && schemaCxt.items !== undefined) {\n      it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n    }\n  }\n\n  mergeValidEvaluated(schemaCxt, valid) {\n    const {\n      it,\n      gen\n    } = this;\n\n    if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n      gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n      return true;\n    }\n  }\n\n}\n\nexports.KeywordCxt = KeywordCxt;\n\nfunction keywordCode(it, keyword, def, ruleType) {\n  const cxt = new KeywordCxt(it, def, keyword);\n\n  if (\"code\" in def) {\n    def.code(cxt, ruleType);\n  } else if (cxt.$data && def.validate) {\n    keyword_1.funcKeywordCode(cxt, def);\n  } else if (\"macro\" in def) {\n    keyword_1.macroKeywordCode(cxt, def);\n  } else if (def.compile || def.validate) {\n    keyword_1.funcKeywordCode(cxt, def);\n  }\n}\n\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\n\nfunction getData($data, {\n  dataLevel,\n  dataNames,\n  dataPathArr\n}) {\n  let jsonPointer;\n  let data;\n  if ($data === \"\") return names_1.default.rootData;\n\n  if ($data[0] === \"/\") {\n    if (!JSON_POINTER.test($data)) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    jsonPointer = $data;\n    data = names_1.default.rootData;\n  } else {\n    const matches = RELATIVE_JSON_POINTER.exec($data);\n    if (!matches) throw new Error(`Invalid JSON-pointer: ${$data}`);\n    const up = +matches[1];\n    jsonPointer = matches[2];\n\n    if (jsonPointer === \"#\") {\n      if (up >= dataLevel) throw new Error(errorMsg(\"property/index\", up));\n      return dataPathArr[dataLevel - up];\n    }\n\n    if (up > dataLevel) throw new Error(errorMsg(\"data\", up));\n    data = dataNames[dataLevel - up];\n    if (!jsonPointer) return data;\n  }\n\n  let expr = data;\n  const segments = jsonPointer.split(\"/\");\n\n  for (const segment of segments) {\n    if (segment) {\n      data = codegen_1._`${data}${codegen_1.getProperty(util_1.unescapeJsonPointer(segment))}`;\n      expr = codegen_1._`${expr} && ${data}`;\n    }\n  }\n\n  return expr;\n\n  function errorMsg(pointerType, up) {\n    return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n  }\n}\n\nexports.getData = getData;","map":{"version":3,"sources":["D:/happyAngular/node_modules/ajv/dist/compile/validate/index.js"],"names":["Object","defineProperty","exports","value","getData","KeywordCxt","validateFunctionCode","boolSchema_1","require","dataType_1","applicability_1","dataType_2","defaults_1","keyword_1","subschema_1","codegen_1","names_1","resolve_1","util_1","errors_1","it","isSchemaObj","checkKeywords","schemaCxtHasRules","topSchemaObjCode","validateFunction","topBoolOrEmptySchema","gen","validateName","schema","schemaEnv","opts","body","code","es5","func","_","default","data","valCxt","$async","funcSourceUrl","destructureValCxtES5","destructureValCxt","instancePath","parentData","parentDataProperty","rootData","dynamicRef","dynamicAnchors","nil","if","var","$comment","commentKeyword","checkNoDefault","let","vErrors","errors","unevaluated","resetEvaluated","typeAndKeywords","returnResults","evaluated","const","assign","schId","schemaId","source","process","subschemaCode","valid","subSchemaObjCode","boolOrEmptySchema","self","key","RULES","all","updateContext","checkAsyncSchema","errsCount","checkUnknownRules","checkRefsAndKeywords","jtd","schemaKeywords","types","getSchemaTypes","checkedTypes","coerceAndCheckDataType","errSchemaPath","$ref","ignoreKeywordsWithRef","schemaHasRulesButRef","logger","warn","undefined","useDefaults","strictSchema","checkStrictMode","baseId","resolveUrl","Error","msg","schemaPath","str","rootName","scopeValue","ref","root","ValidationError","return","throw","assignEvaluated","props","items","Name","typeErrors","allErrors","block","keywordCode","definition","checkStrictTypes","group","rules","groupKeywords","post","shouldUseGroup","type","checkDataType","strictNumbers","iterateKeywords","length","else","reportTypeError","endIf","assignDefaults","rule","shouldUseRule","keyword","meta","strictTypes","checkContextTypes","allowUnionTypes","checkMultipleTypes","checkKeywordTypes","dataTypes","forEach","t","includesType","strictTypesError","join","filter","ts","includes","some","hasApplicableType","schTs","kwdT","constructor","def","validateKeywordUsage","$data","schemaValue","schemaRefOrVal","schemaType","parentSchema","params","schemaCode","validSchemaType","allowUndefined","JSON","stringify","trackErrors","result","condition","successAction","failAction","failResult","not","error","pass","fail","fail$data","or","invalid$data","append","errorParams","errorPaths","setParams","_error","reportExtraError","reportError","$dataError","keyword$DataError","reset","resetErrorsCount","ok","cond","obj","block$data","codeBlock","$dataValid","check$data","validateSchema","elseIf","wrong$DataType","invalid$DataSchema","st","Array","isArray","checkDataTypes","DataType","Wrong","validateSchemaRef","subschema","appl","getSubschema","extendSubschemaData","extendSubschemaMode","nextContext","mergeEvaluated","schemaCxt","toName","mergeValidEvaluated","ruleType","cxt","validate","funcKeywordCode","macroKeywordCode","compile","JSON_POINTER","RELATIVE_JSON_POINTER","dataLevel","dataNames","dataPathArr","jsonPointer","test","matches","exec","up","errorMsg","expr","segments","split","segment","getProperty","unescapeJsonPointer","pointerType"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;\nconst boolSchema_1 = require(\"./boolSchema\");\nconst dataType_1 = require(\"./dataType\");\nconst applicability_1 = require(\"./applicability\");\nconst dataType_2 = require(\"./dataType\");\nconst defaults_1 = require(\"./defaults\");\nconst keyword_1 = require(\"./keyword\");\nconst subschema_1 = require(\"./subschema\");\nconst codegen_1 = require(\"../codegen\");\nconst names_1 = require(\"../names\");\nconst resolve_1 = require(\"../resolve\");\nconst util_1 = require(\"../util\");\nconst errors_1 = require(\"../errors\");\n// schema compilation - generates validation function, subschemaCode (below) is used for subschemas\nfunction validateFunctionCode(it) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            topSchemaObjCode(it);\n            return;\n        }\n    }\n    validateFunction(it, () => boolSchema_1.topBoolOrEmptySchema(it));\n}\nexports.validateFunctionCode = validateFunctionCode;\nfunction validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {\n    if (opts.code.es5) {\n        gen.func(validateName, codegen_1._ `${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {\n            gen.code(codegen_1._ `\"use strict\"; ${funcSourceUrl(schema, opts)}`);\n            destructureValCxtES5(gen, opts);\n            gen.code(body);\n        });\n    }\n    else {\n        gen.func(validateName, codegen_1._ `${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));\n    }\n}\nfunction destructureValCxt(opts) {\n    return codegen_1._ `{${names_1.default.instancePath}=\"\", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? codegen_1._ `, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;\n}\nfunction destructureValCxtES5(gen, opts) {\n    gen.if(names_1.default.valCxt, () => {\n        gen.var(names_1.default.instancePath, codegen_1._ `${names_1.default.valCxt}.${names_1.default.instancePath}`);\n        gen.var(names_1.default.parentData, codegen_1._ `${names_1.default.valCxt}.${names_1.default.parentData}`);\n        gen.var(names_1.default.parentDataProperty, codegen_1._ `${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);\n        gen.var(names_1.default.rootData, codegen_1._ `${names_1.default.valCxt}.${names_1.default.rootData}`);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, codegen_1._ `${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);\n    }, () => {\n        gen.var(names_1.default.instancePath, codegen_1._ `\"\"`);\n        gen.var(names_1.default.parentData, codegen_1._ `undefined`);\n        gen.var(names_1.default.parentDataProperty, codegen_1._ `undefined`);\n        gen.var(names_1.default.rootData, names_1.default.data);\n        if (opts.dynamicRef)\n            gen.var(names_1.default.dynamicAnchors, codegen_1._ `{}`);\n    });\n}\nfunction topSchemaObjCode(it) {\n    const { schema, opts, gen } = it;\n    validateFunction(it, () => {\n        if (opts.$comment && schema.$comment)\n            commentKeyword(it);\n        checkNoDefault(it);\n        gen.let(names_1.default.vErrors, null);\n        gen.let(names_1.default.errors, 0);\n        if (opts.unevaluated)\n            resetEvaluated(it);\n        typeAndKeywords(it);\n        returnResults(it);\n    });\n    return;\n}\nfunction resetEvaluated(it) {\n    // TODO maybe some hook to execute it in the end to check whether props/items are Name, as in assignEvaluated\n    const { gen, validateName } = it;\n    it.evaluated = gen.const(\"evaluated\", codegen_1._ `${validateName}.evaluated`);\n    gen.if(codegen_1._ `${it.evaluated}.dynamicProps`, () => gen.assign(codegen_1._ `${it.evaluated}.props`, codegen_1._ `undefined`));\n    gen.if(codegen_1._ `${it.evaluated}.dynamicItems`, () => gen.assign(codegen_1._ `${it.evaluated}.items`, codegen_1._ `undefined`));\n}\nfunction funcSourceUrl(schema, opts) {\n    const schId = typeof schema == \"object\" && schema[opts.schemaId];\n    return schId && (opts.code.source || opts.code.process) ? codegen_1._ `/*# sourceURL=${schId} */` : codegen_1.nil;\n}\n// schema compilation - this function is used recursively to generate code for sub-schemas\nfunction subschemaCode(it, valid) {\n    if (isSchemaObj(it)) {\n        checkKeywords(it);\n        if (schemaCxtHasRules(it)) {\n            subSchemaObjCode(it, valid);\n            return;\n        }\n    }\n    boolSchema_1.boolOrEmptySchema(it, valid);\n}\nfunction schemaCxtHasRules({ schema, self }) {\n    if (typeof schema == \"boolean\")\n        return !schema;\n    for (const key in schema)\n        if (self.RULES.all[key])\n            return true;\n    return false;\n}\nfunction isSchemaObj(it) {\n    return typeof it.schema != \"boolean\";\n}\nfunction subSchemaObjCode(it, valid) {\n    const { schema, gen, opts } = it;\n    if (opts.$comment && schema.$comment)\n        commentKeyword(it);\n    updateContext(it);\n    checkAsyncSchema(it);\n    const errsCount = gen.const(\"_errs\", names_1.default.errors);\n    typeAndKeywords(it, errsCount);\n    // TODO var\n    gen.var(valid, codegen_1._ `${errsCount} === ${names_1.default.errors}`);\n}\nfunction checkKeywords(it) {\n    util_1.checkUnknownRules(it);\n    checkRefsAndKeywords(it);\n}\nfunction typeAndKeywords(it, errsCount) {\n    if (it.opts.jtd)\n        return schemaKeywords(it, [], false, errsCount);\n    const types = dataType_1.getSchemaTypes(it.schema);\n    const checkedTypes = dataType_1.coerceAndCheckDataType(it, types);\n    schemaKeywords(it, types, !checkedTypes, errsCount);\n}\nfunction checkRefsAndKeywords(it) {\n    const { schema, errSchemaPath, opts, self } = it;\n    if (schema.$ref && opts.ignoreKeywordsWithRef && util_1.schemaHasRulesButRef(schema, self.RULES)) {\n        self.logger.warn(`$ref: keywords ignored in schema at path \"${errSchemaPath}\"`);\n    }\n}\nfunction checkNoDefault(it) {\n    const { schema, opts } = it;\n    if (schema.default !== undefined && opts.useDefaults && opts.strictSchema) {\n        util_1.checkStrictMode(it, \"default is ignored in the schema root\");\n    }\n}\nfunction updateContext(it) {\n    const schId = it.schema[it.opts.schemaId];\n    if (schId)\n        it.baseId = resolve_1.resolveUrl(it.baseId, schId);\n}\nfunction checkAsyncSchema(it) {\n    if (it.schema.$async && !it.schemaEnv.$async)\n        throw new Error(\"async schema in sync schema\");\n}\nfunction commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {\n    const msg = schema.$comment;\n    if (opts.$comment === true) {\n        gen.code(codegen_1._ `${names_1.default.self}.logger.log(${msg})`);\n    }\n    else if (typeof opts.$comment == \"function\") {\n        const schemaPath = codegen_1.str `${errSchemaPath}/$comment`;\n        const rootName = gen.scopeValue(\"root\", { ref: schemaEnv.root });\n        gen.code(codegen_1._ `${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);\n    }\n}\nfunction returnResults(it) {\n    const { gen, schemaEnv, validateName, ValidationError, opts } = it;\n    if (schemaEnv.$async) {\n        // TODO assign unevaluated\n        gen.if(codegen_1._ `${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw(codegen_1._ `new ${ValidationError}(${names_1.default.vErrors})`));\n    }\n    else {\n        gen.assign(codegen_1._ `${validateName}.errors`, names_1.default.vErrors);\n        if (opts.unevaluated)\n            assignEvaluated(it);\n        gen.return(codegen_1._ `${names_1.default.errors} === 0`);\n    }\n}\nfunction assignEvaluated({ gen, evaluated, props, items }) {\n    if (props instanceof codegen_1.Name)\n        gen.assign(codegen_1._ `${evaluated}.props`, props);\n    if (items instanceof codegen_1.Name)\n        gen.assign(codegen_1._ `${evaluated}.items`, items);\n}\nfunction schemaKeywords(it, types, typeErrors, errsCount) {\n    const { gen, schema, data, allErrors, opts, self } = it;\n    const { RULES } = self;\n    if (schema.$ref && (opts.ignoreKeywordsWithRef || !util_1.schemaHasRulesButRef(schema, RULES))) {\n        gen.block(() => keywordCode(it, \"$ref\", RULES.all.$ref.definition)); // TODO typecast\n        return;\n    }\n    if (!opts.jtd)\n        checkStrictTypes(it, types);\n    gen.block(() => {\n        for (const group of RULES.rules)\n            groupKeywords(group);\n        groupKeywords(RULES.post);\n    });\n    function groupKeywords(group) {\n        if (!applicability_1.shouldUseGroup(schema, group))\n            return;\n        if (group.type) {\n            gen.if(dataType_2.checkDataType(group.type, data, opts.strictNumbers));\n            iterateKeywords(it, group);\n            if (types.length === 1 && types[0] === group.type && typeErrors) {\n                gen.else();\n                dataType_2.reportTypeError(it);\n            }\n            gen.endIf();\n        }\n        else {\n            iterateKeywords(it, group);\n        }\n        // TODO make it \"ok\" call?\n        if (!allErrors)\n            gen.if(codegen_1._ `${names_1.default.errors} === ${errsCount || 0}`);\n    }\n}\nfunction iterateKeywords(it, group) {\n    const { gen, schema, opts: { useDefaults }, } = it;\n    if (useDefaults)\n        defaults_1.assignDefaults(it, group.type);\n    gen.block(() => {\n        for (const rule of group.rules) {\n            if (applicability_1.shouldUseRule(schema, rule)) {\n                keywordCode(it, rule.keyword, rule.definition, group.type);\n            }\n        }\n    });\n}\nfunction checkStrictTypes(it, types) {\n    if (it.schemaEnv.meta || !it.opts.strictTypes)\n        return;\n    checkContextTypes(it, types);\n    if (!it.opts.allowUnionTypes)\n        checkMultipleTypes(it, types);\n    checkKeywordTypes(it, it.dataTypes);\n}\nfunction checkContextTypes(it, types) {\n    if (!types.length)\n        return;\n    if (!it.dataTypes.length) {\n        it.dataTypes = types;\n        return;\n    }\n    types.forEach((t) => {\n        if (!includesType(it.dataTypes, t)) {\n            strictTypesError(it, `type \"${t}\" not allowed by context \"${it.dataTypes.join(\",\")}\"`);\n        }\n    });\n    it.dataTypes = it.dataTypes.filter((t) => includesType(types, t));\n}\nfunction checkMultipleTypes(it, ts) {\n    if (ts.length > 1 && !(ts.length === 2 && ts.includes(\"null\"))) {\n        strictTypesError(it, \"use allowUnionTypes to allow union type keyword\");\n    }\n}\nfunction checkKeywordTypes(it, ts) {\n    const rules = it.self.RULES.all;\n    for (const keyword in rules) {\n        const rule = rules[keyword];\n        if (typeof rule == \"object\" && applicability_1.shouldUseRule(it.schema, rule)) {\n            const { type } = rule.definition;\n            if (type.length && !type.some((t) => hasApplicableType(ts, t))) {\n                strictTypesError(it, `missing type \"${type.join(\",\")}\" for keyword \"${keyword}\"`);\n            }\n        }\n    }\n}\nfunction hasApplicableType(schTs, kwdT) {\n    return schTs.includes(kwdT) || (kwdT === \"number\" && schTs.includes(\"integer\"));\n}\nfunction includesType(ts, t) {\n    return ts.includes(t) || (t === \"integer\" && ts.includes(\"number\"));\n}\nfunction strictTypesError(it, msg) {\n    const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;\n    msg += ` at \"${schemaPath}\" (strictTypes)`;\n    util_1.checkStrictMode(it, msg, it.opts.strictTypes);\n}\nclass KeywordCxt {\n    constructor(it, def, keyword) {\n        keyword_1.validateKeywordUsage(it, def, keyword);\n        this.gen = it.gen;\n        this.allErrors = it.allErrors;\n        this.keyword = keyword;\n        this.data = it.data;\n        this.schema = it.schema[keyword];\n        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;\n        this.schemaValue = util_1.schemaRefOrVal(it, this.schema, keyword, this.$data);\n        this.schemaType = def.schemaType;\n        this.parentSchema = it.schema;\n        this.params = {};\n        this.it = it;\n        this.def = def;\n        if (this.$data) {\n            this.schemaCode = it.gen.const(\"vSchema\", getData(this.$data, it));\n        }\n        else {\n            this.schemaCode = this.schemaValue;\n            if (!keyword_1.validSchemaType(this.schema, def.schemaType, def.allowUndefined)) {\n                throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);\n            }\n        }\n        if (\"code\" in def ? def.trackErrors : def.errors !== false) {\n            this.errsCount = it.gen.const(\"_errs\", names_1.default.errors);\n        }\n    }\n    result(condition, successAction, failAction) {\n        this.failResult(codegen_1.not(condition), successAction, failAction);\n    }\n    failResult(condition, successAction, failAction) {\n        this.gen.if(condition);\n        if (failAction)\n            failAction();\n        else\n            this.error();\n        if (successAction) {\n            this.gen.else();\n            successAction();\n            if (this.allErrors)\n                this.gen.endIf();\n        }\n        else {\n            if (this.allErrors)\n                this.gen.endIf();\n            else\n                this.gen.else();\n        }\n    }\n    pass(condition, failAction) {\n        this.failResult(codegen_1.not(condition), undefined, failAction);\n    }\n    fail(condition) {\n        if (condition === undefined) {\n            this.error();\n            if (!this.allErrors)\n                this.gen.if(false); // this branch will be removed by gen.optimize\n            return;\n        }\n        this.gen.if(condition);\n        this.error();\n        if (this.allErrors)\n            this.gen.endIf();\n        else\n            this.gen.else();\n    }\n    fail$data(condition) {\n        if (!this.$data)\n            return this.fail(condition);\n        const { schemaCode } = this;\n        this.fail(codegen_1._ `${schemaCode} !== undefined && (${codegen_1.or(this.invalid$data(), condition)})`);\n    }\n    error(append, errorParams, errorPaths) {\n        if (errorParams) {\n            this.setParams(errorParams);\n            this._error(append, errorPaths);\n            this.setParams({});\n            return;\n        }\n        this._error(append, errorPaths);\n    }\n    _error(append, errorPaths) {\n        ;\n        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);\n    }\n    $dataError() {\n        errors_1.reportError(this, this.def.$dataError || errors_1.keyword$DataError);\n    }\n    reset() {\n        if (this.errsCount === undefined)\n            throw new Error('add \"trackErrors\" to keyword definition');\n        errors_1.resetErrorsCount(this.gen, this.errsCount);\n    }\n    ok(cond) {\n        if (!this.allErrors)\n            this.gen.if(cond);\n    }\n    setParams(obj, assign) {\n        if (assign)\n            Object.assign(this.params, obj);\n        else\n            this.params = obj;\n    }\n    block$data(valid, codeBlock, $dataValid = codegen_1.nil) {\n        this.gen.block(() => {\n            this.check$data(valid, $dataValid);\n            codeBlock();\n        });\n    }\n    check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {\n        if (!this.$data)\n            return;\n        const { gen, schemaCode, schemaType, def } = this;\n        gen.if(codegen_1.or(codegen_1._ `${schemaCode} === undefined`, $dataValid));\n        if (valid !== codegen_1.nil)\n            gen.assign(valid, true);\n        if (schemaType.length || def.validateSchema) {\n            gen.elseIf(this.invalid$data());\n            this.$dataError();\n            if (valid !== codegen_1.nil)\n                gen.assign(valid, false);\n        }\n        gen.else();\n    }\n    invalid$data() {\n        const { gen, schemaCode, schemaType, def, it } = this;\n        return codegen_1.or(wrong$DataType(), invalid$DataSchema());\n        function wrong$DataType() {\n            if (schemaType.length) {\n                /* istanbul ignore if */\n                if (!(schemaCode instanceof codegen_1.Name))\n                    throw new Error(\"ajv implementation error\");\n                const st = Array.isArray(schemaType) ? schemaType : [schemaType];\n                return codegen_1._ `${dataType_2.checkDataTypes(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;\n            }\n            return codegen_1.nil;\n        }\n        function invalid$DataSchema() {\n            if (def.validateSchema) {\n                const validateSchemaRef = gen.scopeValue(\"validate$data\", { ref: def.validateSchema }); // TODO value.code for standalone\n                return codegen_1._ `!${validateSchemaRef}(${schemaCode})`;\n            }\n            return codegen_1.nil;\n        }\n    }\n    subschema(appl, valid) {\n        const subschema = subschema_1.getSubschema(this.it, appl);\n        subschema_1.extendSubschemaData(subschema, this.it, appl);\n        subschema_1.extendSubschemaMode(subschema, appl);\n        const nextContext = { ...this.it, ...subschema, items: undefined, props: undefined };\n        subschemaCode(nextContext, valid);\n        return nextContext;\n    }\n    mergeEvaluated(schemaCxt, toName) {\n        const { it, gen } = this;\n        if (!it.opts.unevaluated)\n            return;\n        if (it.props !== true && schemaCxt.props !== undefined) {\n            it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);\n        }\n        if (it.items !== true && schemaCxt.items !== undefined) {\n            it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);\n        }\n    }\n    mergeValidEvaluated(schemaCxt, valid) {\n        const { it, gen } = this;\n        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {\n            gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));\n            return true;\n        }\n    }\n}\nexports.KeywordCxt = KeywordCxt;\nfunction keywordCode(it, keyword, def, ruleType) {\n    const cxt = new KeywordCxt(it, def, keyword);\n    if (\"code\" in def) {\n        def.code(cxt, ruleType);\n    }\n    else if (cxt.$data && def.validate) {\n        keyword_1.funcKeywordCode(cxt, def);\n    }\n    else if (\"macro\" in def) {\n        keyword_1.macroKeywordCode(cxt, def);\n    }\n    else if (def.compile || def.validate) {\n        keyword_1.funcKeywordCode(cxt, def);\n    }\n}\nconst JSON_POINTER = /^\\/(?:[^~]|~0|~1)*$/;\nconst RELATIVE_JSON_POINTER = /^([0-9]+)(#|\\/(?:[^~]|~0|~1)*)?$/;\nfunction getData($data, { dataLevel, dataNames, dataPathArr }) {\n    let jsonPointer;\n    let data;\n    if ($data === \"\")\n        return names_1.default.rootData;\n    if ($data[0] === \"/\") {\n        if (!JSON_POINTER.test($data))\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        jsonPointer = $data;\n        data = names_1.default.rootData;\n    }\n    else {\n        const matches = RELATIVE_JSON_POINTER.exec($data);\n        if (!matches)\n            throw new Error(`Invalid JSON-pointer: ${$data}`);\n        const up = +matches[1];\n        jsonPointer = matches[2];\n        if (jsonPointer === \"#\") {\n            if (up >= dataLevel)\n                throw new Error(errorMsg(\"property/index\", up));\n            return dataPathArr[dataLevel - up];\n        }\n        if (up > dataLevel)\n            throw new Error(errorMsg(\"data\", up));\n        data = dataNames[dataLevel - up];\n        if (!jsonPointer)\n            return data;\n    }\n    let expr = data;\n    const segments = jsonPointer.split(\"/\");\n    for (const segment of segments) {\n        if (segment) {\n            data = codegen_1._ `${data}${codegen_1.getProperty(util_1.unescapeJsonPointer(segment))}`;\n            expr = codegen_1._ `${expr} && ${data}`;\n        }\n    }\n    return expr;\n    function errorMsg(pointerType, up) {\n        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;\n    }\n}\nexports.getData = getData;\n"]},"metadata":{},"sourceType":"script"}
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-countdown', ['exports', '@angular/core', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-countdown'] = {}, global.ng.core, global.ng.common));
}(this, (function (exports, i0, common) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);

    exports.CountdownStatus = void 0;
    (function (CountdownStatus) {
        CountdownStatus[CountdownStatus["ing"] = 0] = "ing";
        CountdownStatus[CountdownStatus["pause"] = 1] = "pause";
        CountdownStatus[CountdownStatus["stop"] = 2] = "stop";
        CountdownStatus[CountdownStatus["done"] = 3] = "done";
    })(exports.CountdownStatus || (exports.CountdownStatus = {}));

    var CountdownTimer = /** @class */ (function () {
        function CountdownTimer(ngZone) {
            this.ngZone = ngZone;
            this.fns = [];
            this.commands = [];
            this.nextTime = 0;
            this.ing = false;
        }
        CountdownTimer.prototype.start = function () {
            var _this = this;
            if (this.ing === true) {
                return;
            }
            this.ing = true;
            this.nextTime = +new Date();
            this.ngZone.runOutsideAngular(function () {
                _this.process();
            });
        };
        CountdownTimer.prototype.process = function () {
            var _this = this;
            while (this.commands.length) {
                this.commands.shift()();
            }
            var diff = +new Date() - this.nextTime;
            var count = 1 + Math.floor(diff / 100);
            diff = 100 - (diff % 100);
            this.nextTime += 100 * count;
            for (var i = 0, len = this.fns.length; i < len; i += 2) {
                var frequency = this.fns[i + 1];
                // 100/s
                if (0 === frequency) {
                    this.fns[i](count);
                    // 1000/s
                }
                else {
                    // 先把末位至0，再每次加2
                    frequency += 2 * count - 1;
                    var step = Math.floor(frequency / 20);
                    if (step > 0) {
                        this.fns[i](step);
                    }
                    // 把末位还原成1
                    this.fns[i + 1] = (frequency % 20) + 1;
                }
            }
            if (!this.ing) {
                return;
            }
            setTimeout(function () { return _this.process(); }, diff);
        };
        CountdownTimer.prototype.add = function (fn, frequency) {
            var _this = this;
            this.commands.push(function () {
                _this.fns.push(fn);
                _this.fns.push(frequency === 1000 ? 1 : 0);
                _this.ing = true;
            });
            return this;
        };
        CountdownTimer.prototype.remove = function (fn) {
            var _this = this;
            this.commands.push(function () {
                var i = _this.fns.indexOf(fn);
                if (i !== -1) {
                    _this.fns.splice(i, 2);
                }
                _this.ing = _this.fns.length > 0;
            });
            return this;
        };
        return CountdownTimer;
    }());
    CountdownTimer.decorators = [
        { type: i0.Injectable }
    ];
    CountdownTimer.ctorParameters = function () { return [
        { type: i0.NgZone }
    ]; };

    // tslint:disable: no-inferrable-types
    var CountdownGlobalConfig = /** @class */ (function () {
        function CountdownGlobalConfig(locale) {
            var _this = this;
            this.locale = locale;
            this.demand = false;
            this.leftTime = 0;
            this.format = 'HH:mm:ss';
            this.timezone = '+0000';
            this.formatDate = function (_a) {
                var date = _a.date, formatStr = _a.formatStr, timezone = _a.timezone;
                return common.formatDate(new Date(date), formatStr, _this.locale, timezone || _this.timezone || '+0000');
            };
        }
        return CountdownGlobalConfig;
    }());
    CountdownGlobalConfig.ɵprov = i0__namespace.ɵɵdefineInjectable({ factory: function CountdownGlobalConfig_Factory() { return new CountdownGlobalConfig(i0__namespace.ɵɵinject(i0__namespace.LOCALE_ID)); }, token: CountdownGlobalConfig, providedIn: "root" });
    CountdownGlobalConfig.decorators = [
        { type: i0.Injectable, args: [{ providedIn: 'root' },] }
    ];
    CountdownGlobalConfig.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] }
    ]; };

    var CountdownComponent = /** @class */ (function () {
        function CountdownComponent(locale, timer, defCog, cdr, ngZone) {
            this.locale = locale;
            this.timer = timer;
            this.defCog = defCog;
            this.cdr = cdr;
            this.ngZone = ngZone;
            this.frequency = 1000;
            this._notify = {};
            this.status = exports.CountdownStatus.ing;
            this.isDestroy = false;
            this.i = {};
            this.left = 0;
            this.event = new i0.EventEmitter();
        }
        Object.defineProperty(CountdownComponent.prototype, "config", {
            get: function () {
                return this._config;
            },
            set: function (i) {
                if (i.notify != null && !Array.isArray(i.notify) && i.notify > 0) {
                    i.notify = [i.notify];
                }
                this._config = i;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Start countdown, you must manually call when `demand: false`
         */
        CountdownComponent.prototype.begin = function () {
            this.status = exports.CountdownStatus.ing;
            this.callEvent('start');
        };
        /**
         * Restart countdown
         */
        CountdownComponent.prototype.restart = function () {
            if (this.status !== exports.CountdownStatus.stop) {
                this.destroy();
            }
            this.init();
            this.callEvent('restart');
        };
        /**
         * Stop countdown, must call `restart` when stopped, it's different from pause, unable to recover
         */
        CountdownComponent.prototype.stop = function () {
            if (this.status === exports.CountdownStatus.stop) {
                return;
            }
            this.status = exports.CountdownStatus.stop;
            this.destroy();
            this.callEvent('stop');
        };
        /**
         * Pause countdown, you can use `resume` to recover again
         */
        CountdownComponent.prototype.pause = function () {
            if (this.status === exports.CountdownStatus.stop || this.status === exports.CountdownStatus.pause) {
                return;
            }
            this.status = exports.CountdownStatus.pause;
            this.callEvent('pause');
        };
        /**
         * Resume countdown
         */
        CountdownComponent.prototype.resume = function () {
            if (this.status === exports.CountdownStatus.stop || this.status !== exports.CountdownStatus.pause) {
                return;
            }
            this.status = exports.CountdownStatus.ing;
            this.callEvent('resume');
        };
        CountdownComponent.prototype.callEvent = function (action) {
            this.event.emit({ action: action, left: this.left, status: this.status, text: this.i.text });
        };
        CountdownComponent.prototype.init = function () {
            var _this = this;
            var _a = this, locale = _a.locale, defCog = _a.defCog;
            var config = (this.config = Object.assign(Object.assign(Object.assign({}, new CountdownGlobalConfig(locale)), defCog), this.config));
            // tslint:disable-next-line: no-bitwise
            var frq = (this.frequency = ~config.format.indexOf('S') ? 100 : 1000);
            this.status = config.demand ? exports.CountdownStatus.pause : exports.CountdownStatus.ing;
            this.getLeft();
            // bind reflow to me
            var _reflow = this.reflow;
            this.reflow = function (count, force) {
                if (count === void 0) { count = 0; }
                if (force === void 0) { force = false; }
                return _reflow.apply(_this, [count, force]);
            };
            if (Array.isArray(config.notify)) {
                config.notify.forEach(function (time) {
                    if (time < 1) {
                        throw new Error("The notify config must be a positive integer.");
                    }
                    time = time * 1000;
                    time = time - (time % frq);
                    _this._notify[time] = true;
                });
            }
            this.timer.add(this.reflow, frq).start();
            this.reflow(0, true);
        };
        CountdownComponent.prototype.destroy = function () {
            this.timer.remove(this.reflow);
            return this;
        };
        /**
         * 更新时钟
         */
        CountdownComponent.prototype.reflow = function (count, force) {
            var _this = this;
            if (count === void 0) { count = 0; }
            if (force === void 0) { force = false; }
            if (this.isDestroy) {
                return;
            }
            var _a = this, status = _a.status, config = _a.config, _notify = _a._notify;
            if (!force && status !== exports.CountdownStatus.ing) {
                return;
            }
            var value = (this.left = this.left - this.frequency * count);
            if (value < 1) {
                value = 0;
            }
            this.i = {
                value: value,
                text: config.formatDate({ date: value, formatStr: config.format, timezone: config.timezone }),
            };
            if (typeof config.prettyText === 'function') {
                this.i.text = config.prettyText(this.i.text);
            }
            this.cdr.detectChanges();
            if (config.notify === 0 || _notify[value]) {
                this.ngZone.run(function () {
                    _this.callEvent('notify');
                });
            }
            if (value === 0) {
                this.ngZone.run(function () {
                    _this.status = exports.CountdownStatus.done;
                    _this.destroy();
                    _this.callEvent('done');
                });
            }
        };
        /**
         * 获取倒计时剩余帧数
         */
        CountdownComponent.prototype.getLeft = function () {
            var _a = this, config = _a.config, frequency = _a.frequency;
            var left = config.leftTime * 1000;
            var end = config.stopTime;
            if (!left && end) {
                left = end - new Date().getTime();
            }
            this.left = left - (left % frequency);
        };
        CountdownComponent.prototype.ngOnInit = function () {
            this.init();
            if (!this.config.demand) {
                this.begin();
            }
        };
        CountdownComponent.prototype.ngOnDestroy = function () {
            this.isDestroy = true;
            this.destroy();
        };
        CountdownComponent.prototype.ngOnChanges = function (changes) {
            if (!changes.config.firstChange) {
                this.restart();
            }
        };
        return CountdownComponent;
    }());
    CountdownComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'countdown',
                    template: "\n    <ng-container *ngIf=\"!render\">\n      <span [innerHTML]=\"i.text\"></span>\n    </ng-container>\n    <ng-container *ngTemplateOutlet=\"render; context: { $implicit: i }\"></ng-container>\n  ",
                    host: { '[class.count-down]': 'true' },
                    encapsulation: i0.ViewEncapsulation.None,
                    changeDetection: i0.ChangeDetectionStrategy.OnPush
                },] }
    ];
    CountdownComponent.ctorParameters = function () { return [
        { type: String, decorators: [{ type: i0.Inject, args: [i0.LOCALE_ID,] }] },
        { type: CountdownTimer },
        { type: CountdownGlobalConfig },
        { type: i0.ChangeDetectorRef },
        { type: i0.NgZone }
    ]; };
    CountdownComponent.propDecorators = {
        config: [{ type: i0.Input }],
        render: [{ type: i0.Input }],
        event: [{ type: i0.Output }]
    };

    var CountdownModule = /** @class */ (function () {
        function CountdownModule() {
        }
        return CountdownModule;
    }());
    CountdownModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    providers: [CountdownTimer],
                    declarations: [CountdownComponent],
                    exports: [CountdownComponent],
                },] }
    ];

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CountdownComponent = CountdownComponent;
    exports.CountdownGlobalConfig = CountdownGlobalConfig;
    exports.CountdownModule = CountdownModule;
    exports.CountdownTimer = CountdownTimer;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-countdown.umd.js.map
